# CHAPTER14 데이터베이스 프로그래밍 기초

### **데이터 베이스**

- 데이터를 지속적으로 관리하고 보호하는 것을 주목적으로 함
- dbms
    - 데이터 베이스 관리 시스템
    - 오라클, MySQL,MS SQL 서버 등
- 테이블 : RDBMS에서 데이터를 저장하는 장소
- 레코드 : 논리적으로 연관된 필드의 집합을 의미
- 스키마 : 테이블의 구조와 관련된 정보
- Primary key : 하나의 테이블에 저장된 모든 레코드가 서로 다른 값을 갖는 컬럼
- 인덱스
    - 데이터의 순서를 미리 정렬해서 저장할 때 사용
    - primary key 또한 인덱스의 일종, primary key는 중복된 값을 가질 수 없지만 인덱스는 중복된 값에 대한 정렬이 가능

**db에서 키 종류**

![KakaoTalk_20230810_140957286](https://github.com/HoChangSUNG/mentoring/assets/76422685/59a1acdc-11ce-4f3d-b9e4-6e8f55a1993a)
![KakaoTalk_20230810_140957286_01](https://github.com/HoChangSUNG/mentoring/assets/76422685/20c66212-519f-4fe1-8329-d40348f541b0)

- **슈퍼키** : 레코드를 유일하게 식별할 수 있는 하나의 속성 또는 속성 집합
    - 위 사진에서 슈퍼키들
        - (주민번호), (주민번호,이름), (고객번호, 주민번호) ……
- **후보키** : 레코드를 유일하게 식별할 수 있는 속성의 최소 집합
    - 위 사진에서 후보키
        - (주민번호), (고객번호)
- **기본키** : 여러 후보키 중 하나를 선정하여 대표로 삼은 키
    - 기본키 제약조건
        - null 값을 허용하지 않는다
        - 테이블 내 레코드를 식별할 수 있는 고유한 값을 가져야 한다.
- **대체키** : 기본키로 선정되지 않은 후보키
    - 후보키 중 주민번호가 기본키로 선정 → 고객번호가 대체키
- **대리키**
    - 기본키가 보안을 필요로 하거나, 여러 개의 속성으로 구성되어 복잡하거나, 마땅한 기본키가 없을 때 가상의 속성을 만들어 기본키로 삼는 키
    - 대리키 = 인조키
- **외래키**
    - 다른 테이블의 기본키를 참조하는(값으로 가지는) 속성, 테이블 간의 관계(relationship)를 표현
    - 특징
        - 참조되는 값이 변경되면 참조하는 값도 변경된다
        - NULL 값과 중복값 등 허용
        - 자기 자신의 기본키를 참조하는 외래키도 가능
        - 외래키가 기본키의 일부가 될 수 있다.
- **복합키 : 두 개 이상의 속성으로 이루어진 키**

키 참고 : [오라클로 배우는 데이터베이스 개론과 실습 2탄](https://www.yes24.com/Product/Goods/91452369)

**데이터베이스 프로그래밍 필수 요소**

- DBMS : 데이터베이스 관리 시스템
- DB : 데이터를 저장할 공간
- DBMS 클라이언트 : 데이터베이스를 사용하는 어플리케이션

### SQL(structured Query Language)

- 데이터베이스로부터 데이터를 조회하고 삭제하는 등의 작업을 수행할 때 사용하는 언어
- 주요 SQL 타입
    - CHAR : 확정 길이의 문자열 저장, 표준의 경우 255글자까지만 저장 가능
    - VARCHAR  : 가변 길이의 문자열 저장, 표준의 경우 255글자까지만 저장 가능
    - LONG VARCHAR : 긴 가변 길이의 문자열 저장
    - NUMERIC : 숫자를 저장
    - DECIMAL : 십진수를 저장
    - INTEGER : 정수를 저장
    - TIMESTAMP : 날짜와 시간을 저장
    - TIME : 시간을 저장
    - DATE : 날짜를 저장
    - CLOB : 대량의 문자열 데이터 저장
    - BLOB : 대량의 이진 데이터 저장

### JDBC 프로그래밍

- JDBC API 구조
    
    ![KakaoTalk_20230807_194004076](https://github.com/HoChangSUNG/mentoring/assets/76422685/65314152-f496-466b-b97d-7abb02141481)

    - JDBC API
        - 자바에서 데이터베이스와 관련된 작업을 처리할 때 사용하는 API
        - 자바 응용 프로그램에서 데이터베이스를 연결하고 데이터를 제어하는 일련의 인터페이스들과 클래스들 의미
        - DBMS 종류 상관없이 JDBC API를 사용하여 DB 작업을 처리할 수 있음
    - JDBC 드라이버
        - DBMS와의 통신을 담당하는 자바 클래스
        - DB 벤더에서 자신들의 DB에 맞게 JDBC 인터페이스를 구현해서 제공하는 것
        - DBMS마다 별도의 JDBC 드라이버 필요, 애플리케이션 실행 시 한번만 로딩되면 됨
            
            (어플리케이션 시작 시점에 로딩하는 것이 가장 좋음)
            
            - Class.forName()를 통해 JDBC 드라이버에 해당하는 클래스들을 로딩하여 자동으로 JDBC 드라이버로 등록
    - 순서
        - 애플리케이션에서 JDBC 인터페이스를 호출하면 JDBC 인터페이스를 구현한 JDBC 드라이버를 호출하여 DB에 접근
            
            (JDBC 드라이버 로딩 → Connection 획득 → 쿼리 실행 → 쿼리 종료 → Connection 종료)
            
    
    ### PreparedStatement vs Statement
    
    - **가장 큰 차이점은 캐시 사용 여부**
    - Statement는 쿼리를 실행할 때마다 db에 보내고, db는  sql 쿼리를 파싱하고 컴파일한 후 실행
    - PreparedStatement는 쿼리를 실행하기 전에 PreparedStatement가 생성될 때 SQL 쿼리를 DB로 보내 DB가 해당 쿼리를 컴파일하여 캐시에 저장
        
        이후 같은 쿼리 사용할 때는 캐시에 저장된 컴파일된 쿼리를 사용해서 실행함 → SQL 파싱과 컴파일 오버헤드 줄음 → 성능향상
        
    
    ### PreparedStatement 사용해야 하는 이유
    
    - 성능 향상
        - PreparedStatement는 Statement와 다르게  캐싱을 하기 때문 성능 향상이 가능
    - 값 변환을 자동으로 하기 위해
        - 작은 따옴표(`’`)를 PreparedStatement는 Statement와 다르게 알아서 값을 변경해주기 때문
    - 간결한 코드를 위해
        - PreparedStatement는 ?를 통해 필요한 값을 간단하게 지정할 수 있기 때문

### 트랜잭션

- 쪼갤 수 없는 업무 처리의 최소 단위로서 데이터 베이스에서 하나의 거래를 안전하게 처리하도록 보장해주는 것, 여러 개의 쿼리를 마치 한개의 쿼리처럼 처리할 수 있도록 해줌
- 트랜잭션 시작 이후 실행되는 쿼리 결과는 DBMS에 곧바로 반영되지 않고 임시로 보관
- **커밋** : 모든 작업이 성공하여 임시로 보관한 쿼리 결과를 DB에 반영하는 것
- **롤백** : 작업 중 문제가 발생하여 트랜잭션 처리 과정에서 발생한 변경 사항을 취소하여 DB에 반영하지 않는 것
- **ACID**
    - Atomicity(원자성) : ****한 트랜잭션에 포함된 작업은 전부 수행거나 아니면 전부 수행되지 않아야 한다.****
    - Consistency(일관성) : 트랜잭션을 수행하기 전이나 수행한 후나 db는 항상 일관된 상태를 유지해야 한다
    - Isolation(격리성) : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 한다.
    - Durability(지속성) : 성공적으로 완료된 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.
    
- 트랜잭션 구현 방법 2가지
    - JDBC의 auto commit 모드를 false로 지정 → 단일 데이터베이스에 접근하는 경우
        - `setAutoCommit(false)`
    - JTA 이용하는 방법 → 두개 이상의 데이터베이스를 트랜잭션으로 처리하려는 경우

### 커넥션 풀

- db와 연결된 커넥션을 미리 만들어서 풀에 저장해 두고 있다가 필요할 때에 커넥션을 풀에서 가져다 쓰고 다시 풀에 반환하는 것
- 사용 이유
    - 요청할 때마다 커넥션 생성하고 닫는데 시간이 소모되기 때문에 동시 접속자가 많은 웹 사이트에서는 전체 성능 낮아지는 문제 해결하기 위해
- 특징
    - 풀에 커넥션이 미리 생성되어 있어 커넥션 생성 비용을 줄일 수 있음
    - 커넥션을 재사용하여 커넥션 수가 일정하게 유지됨

- 커넥션 풀 초기화
    - 실제 커넥션을 생성할 ConnectionFactory를 생성
    - 커넥션 풀로 사용할 PoolableConnection을 생성하는 PoolableConnectionFactory 생성
    - 커넥션 풀의 설정 정보를 생성
    - 커넥션 풀을 사용할 JDBC 드라이버 등록

- 커넥션 검사 기준
    1. 커넥션이 최소 유휴 시간보다 오래 풀에 있는 경우
    2. 케넥션이 유효한지 여부 확인
    - 검사 이유 : 오랜 시간 사용되지 않은 커넥션은 dbms와 연결이 끊길 가능성이 높기 때문에 주기적으로 커넥션 풀에 있는 커넥션을 검사해서 사전에 제거해줘야 하기 때문

- 커넥션 풀 속성(apache common dbcp)
    - maxTotal
        - 최대 커넥션 개수
        - 불필요하게 커져 dbms가 수용할 수 있는 수준 넘어서면 오히려 전체 성능에 좋지 않은 영향 줌
    - minIdle
        - 풀에 있는 커넥션 최소 개수
        - 0으로 지정시 풀에 저장된 커넥션 개수가 0이 되면 커넥션이 필요할 때 커넥션ㄴ을 생성하므로 커넥션 최소 개수는 시스템 사용이 가장 적은 시간을 기준으로 설정
    - timeBetweenEvctionRusMillis
        - 풀에 있는 유휴 커넥션 검사 주기 설정
        - 이 값을 설정해서 주기적으로 유휴 커넥션을 검사하고 제거
    - maxWaitMillis
        - 커넥션 풀 안의 커넥션이 고갈됐을 때 커넥션 반납을 대기하는 시간
