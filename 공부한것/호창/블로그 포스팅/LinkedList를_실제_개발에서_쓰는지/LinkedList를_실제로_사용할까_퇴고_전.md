## 서론

대부분의 블로그에 ArrayList와 LinkedList에 대해 설명할 때 다음과 같은 내용이 많이 보인다.

<br>

ArrayList는 중간에 요소의 삽입할 경우 삽입하려는 위치 뒤에 있는 요소들을 한 칸씩 뒤로 미뤄야 하고, 중간에 있는 요소를 삭제할 경우 삭제한 요소 다음에 위치한 요소들을 한칸씩 앞으로 이동시켜야 해서 O(n) 시간이 걸린다.  
하지만 ArrayList는 random access가 가능하여 조회시 O(1) 시간 복잡도만에 가능하다.
<br>

이에 반해  LinkedList는 요소 탐색시 반드시 맨 앞에 있는 head 노드부터 탐색해서 O(N)이 걸리고, 요소 삽입과 삭제 시 노드의 연결만 바꾸어주면 되기 때문에 O(1)의 시간 복잡도가 걸린다.  
따라서 중간에 요소의 삽입과 삭제가 자주 일어나는 경우에는 LinkedList를 요소의 탐색이 자주 일어나는 경우에는 ArrayList를 사용하라고 한다.
<br><br>

그렇다면 실제로 LinkedList를 개발할 때 사용할까?  
멘토링 시간에 ArrayList와 LinkedList에 대해 얘기하는데,  
**멘토님이 실제로 개발에서 LinkedList를 사용할까요?** 라는 질문을 하셨다.  
그리고 이와 관련해서 생각해보면 좋을 아티클을 나와 팀원에게 공유해주시고 고민해보라고 하셨다.  
<br>

**아티클**  
https://discuss.kotlinlang.org/t/why-kotlin-does-not-provide-linkedlist-implementation/15991  
https://twitter.com/joshbloch/status/583813919019573248

위 아티클은 **코틀린에서 List 구현체로 왜 LinkedList 구현체를 제공하지 않는지 사람들이 토론**한 내용이다.  
코틀린과 관련된 내용이지만 코틀린뿐만 아니라 다른 언어에서도 실제로 개발할 때 LinkedList를 사용하는지와 관련해서 토론해보면 좋은 아티클이다.  
이 아티클을 읽고 실**제로 개발할 때 LinkedList를 사용하는지 생각**해보자.  

<br><br>

## **LinkedList를 실제 개발에서 잘 쓰지 않는 이유**
위 아티클 내용을 기반으로 생각했을 때 LinkedList는 실제 개발에서 거의 사용되지 않는다고 판단된다.  
실제 개발에서 **LinekdList를 사용하지 않는 이유**는 다음 두 가지 이유 때문이라고 생각한다.
<br>

1. 애플리케이션에서 리스트 중간에 삽입과 삭제가 일어날 일이 거의 없기 때문  
2. CS 관점에서 LinkedList보다 ArrayList가 더 빠르기 때문

이제 이 이유에 대해 자세히 이야기해보자.
<br><br>

### 1. 애플리케이션에서 리스트 중간에 삽입과 삭제가 일어날 일이 거의 없기 때문
우리가 실제 애플리케이션을 개발하는 상황을 생각해보자.  
보통 우리가 데이터를 조회할 경우 db에서 원하는 정보를 얻어 List에 순서대로 저장한다.  
또한 조회된 데이터에서 특정 데이터를 삭제할 때, 삭제할 데이터의 식별 번호를  클라이언트가 서버에 전달하고 서버에서 특정 식별 번호를 가진 row를 DB에 쿼리문을 날려 삭제하는 방식으로 코드를 작성한다.  
이 과정에서 List에서 중간에 존재하는 특정 요소를 삭제하지 않고 DB에 직접 삭제할 ROW의 식별 번호를 전달하는 방식으로 동작한다.  
<br>
이처럼 프로젝트를 진행할 때 List의 중간 요소를 삭제하는 부분은 사실상 없고, 보통 데이터 목록 조회를 위해서 List를 사용한다.  
이런 이유로 LinkedList를 사용할 일 자체가 거의 없다.

<br><br>

### 2. CS 관점에서 LinkedList보다 ArrayList가 더 빠르기 때문
LinkedList보다 ArrayList가 더 빠른 이유는 CPU 캐시 때문이다.  
CPU로 메모리를 로딩할 때 캐시 라인 사이즈만큼 연속된 메모리를 읽어 CPU 캐시에 저장한다.  
이는 RAM에서 데이터를 읽어오는 시간이 CPU에서 처리하는 시간보다 훨씬 오래 걸리기 때문에 이 시간 차이를 줄이기 위해 CPU 캐시를 사용한다.  

이 내용을 arrayList와 LinkedList에 대입해 생각해보면 cpu 캐시에 메모리를 로드할 때 캐시 라인 사이즈만큼 ram의 연속된 데이터를 읽어온다  
따라서 배열은 연속적인 메모리 공간에 저장되기 때문에 배열의 요소를 CPU로 로드하면 그 이후의 배열의 요소들도 CPU 캐시에 저장되는 것이다. 
즉, ArrayList는 CPU 캐시에 메모리를 로드할 때 연속적인 메모리 공간을 가져 같이 캐시에 로드되기 때문에 LinkedList보다 속도가 빠르다는 것이다.
<br><br>

### LinkedList는 CPU 캐시에 같이 로드되지 않는 것일까?
**나의 개인적인 생각**으로는 cpu 캐시에 로드되지 않을 것이라고 생각한다.  
그 이유는 LinkedList의 노드는 객체로서 heap 영역에 저장되고, heap 영역은 다른 스레드들과 공유한다. LinkedList에 데이터를 추가할 때, 다른 스레드가 객체를 생성하여 heap 영역에 저장한다고 하자  
heap 영역은 기본적으로 메모리에 순서대로 객체를 저장하지만 여러 스레드가 객체를 생성하기 때문에 LinkedList의 노드가 heap 영역의 순서대로 저장된다고 보장하지 못한다.  
오히려 연속적인 메모리 위치에 저장되지 않을 것이라고 생각된다.  
이러한 이유로 cpu 캐시에 LinkedList의 노드들이 같이 cpu 캐시에 로드되지 않을 것이라고 생각한다.  
<br><br><br>

## 결론 및 생각
### 결론
- 실제 개발할 때 LinkedList를 사용할 일이 없기 때문에 LinkedList를 사용하지 않고, ArrayList를 위주로 사용한다.  
<br>

### 생각
- 이론적으로는 중간에 삽입, 삭제가 빈번하게 일어나면 LinkedList를 사용한다라고 알고 있었는데, 실제로 이 LinkedList를 사용할까? 라는 생각은 해보지 않은 것 같다.  
- 이론 내용을 실제로 개발할 때 사용하는지를 같이 생각해보면 내가 좀 더 다양한 방면으로 생각해볼 수 있을 것 같다.