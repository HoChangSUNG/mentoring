# 6장 신뢰성

테스트를 작성하는 이유는 신뢰할 수 있는 코드를 만들기 위해서이다.  
따라서 테스트 자체도 믿음직해야 하는데, 테스트를 믿지 못하면 제품 코드를 쉽게 바꾸지 못한다.  
이번 장은 테스트의 신뢰성에 누를 끼치는 요인과 이에 대한 테스트 냄새에 대해 설명한다.  
(테스트를 신뢰할 수 없고 불안정하게 만드는 냄새)  

<br>

## 테스트 냄새

- 주석으로 변한 테스트
- 오해를 낳는 주석
- 절대 실패하지 않는 테스트
- 지키지 못할 약속
- 낮아진 기대치
- 플랫폼 편견
- 조건부 테스트


<br>

### 주석으로 변한 테스트

- 아무런 설명도 없이 읽는 이에게 혼란만을 안겨주는 경우
- 주석으로 변한 코드는 실행될 수 없는 코드
- 주석 처리한 이유를 바로 알아내지 못한다면, 앞으로도 알아내지 못할 가능성이 크다.
    
    그렇다면 주석을 제거하는 것이 낫다
    
- 정리하면, 주석으로 변한 테스트는 주석 처리한 이유를 찾기 위해 프로그래머의 아까운 시간을 좀먹게 하는 고약한 냄새다.

<br>

### 오해를 낳는 주석

- 코드가 주석처럼 동작하지 않지만 주석을 보고 코드가 주석처럼 동작한다고 믿어버리는 문제
- 핵심은 주석을 믿을 수 없다는 것
- 해결방법
    - 주석을 제거하는 동시에 코드를 리팩토링하야 주석 없이도 읽을 수 있도록 하는 것
- 좋은 주석과 나쁜 주석
    - 좋은 주석 : 코드가 그렇게 작성될 수밖에 없던 당위성 설명하는 주석(프로그래밍 문법만으로 표현 불가능해서)
    - 나쁜 주석 : 코드가 무엇을 하는지 설명하는 주석
    - 즉, 좋은 주석 → 왜?를 설명
        
        나쁜 주석 → 무엇을?을 설명
        

<br>

### 절대 실패하지 않는 테스트

- 예외가 발생했는가를 확인하는 테스트에서 빈번하게 목격
- 예외가 발생하지 않았을 때 fail()호출하는 것을 까먹을 수 있고, catch 블록에서 실수로 집어삼킬 수도 있다
- 따라서 @Test의 expected 속성을 이용해 실패해야 할 상황에서는 반드시 실패해야 테스트가 성공되도록 하는 것이 중요하다.
- **테스트라면 실패해야 할 상황에서는 반드시 실패해야 한다.**

<br>

### 지키지 못할 약속

- 테스트가 자신이 내세운 것보다 훨씬 적은 것을 검사하거나, 아무것도 검사하지 않는다는 것이 핵심
    - 아무 일도 안하는 테스트
    - 무언가 일은 하지만, 검증은 전혀하지 않는 테스트(단언문 없는 테스트)
    - 이름값 못하는 테스트
- 코드를 주석 형태로 남겨놓기보단 아예 지워버리고, 단언문을 빠뜨리지 않도록 신경쓰고, 테스트의 이름과 실제로 검사하는 내용이 일치하는지 살펴봐야 함

<br>

### 낮아진 기대치

- 쉬운 길을 찾다 보니 검증 정확도와 정밀도까지 낮춰버림
- 테스트는 자신이 명시한 동작에 문제가 생기면 실패해야 하지만, 낮아진 기대치는 실패해야 할 상황에서도 실패하지 않는 지나치게 강건한 테스트를 만들어냄
- 낮아진 기대치는 예상한 동작을 제대로 기술하지 못하는 모호한 단언문으로 인해 실제로는 기능 일부가 동작하지 않는데, 그 모호한 단언문은 성공하고 있다.
    
    이러한 문제를 해결하기 위해 기준치를 다시 높여 더 명확하고 정교하게 단언하면 낮아진 기대치를 해결할 수 있다.
    
- 테스트가 세부 내용까지 다룬다는 게 나쁠 이유는 없지만 지나치게 구체적인 단언문은 픽셀 퍼펙션 문제를 일으킬 위험이 존재한다.

<br>

### 플랫폼 편견

- 모든 플랫폼(윈도우, ubuntu 등)을 동등하게 다루지 못하는 테스트 냄새
- 테스트가 하부 플랫폼에 따라 다른 경로(if,else → isMac(), isWindows()에 따라 다른 로직 실행)를 타고 다른 단언문을 호출하는 경우
- 특정 플랫폼에서만 수행해야 할 기능을 찾아 격리하고, 그 기능을 검증하는 테스트도 따로 만들어서 해결
- 문제 예시
    
    ```java
    @Test
    public void knowsTheSystemsDownloadDirectory() throws Exception{
    	String dir = Configuration.downloadDir().getAbsolutePath();
    	Platform platform = Platform.current();
    	if(platform.isMac()){
    		assertEquals(dir, matches("/Users/(.*?)/Downloads"));
    	}else if(platform.isWindows()){
    		assertThat(dir.toLowerCase(), matches("C:\\USERS\\(.*?)\\downloads"));
    	}
    }
    ```
    
    - 플랫폼에 따라 서로 다른 단언문을 실행 → 테스트를 돌리는 그 플랫폼에서의 동작만 확인 → 만약 같은 테스트를 다른 플랫폼에서 돌렸다면 실패했을지라도, 당장은 테스트가 성공한다고 보고 있음
- 해결 예시
    
    ```java
    @Test
    public void knowsheSystemsDownloadDirectoryOnMacOsX() throws Exception{
    	String downloadsDir = new MacOsX().downloadDir();
    	assertEquals(downloadDir, matches("/Users/(.*?)/Downloads"));
    }
    
    @Test
    public void knowsheSystemsDownloadDirectoryOnWindows() throws Exception{
    	String downloadsDir = new Windows().downloadDir();
    	assertEquals(downloadDir.toLowerCase(), matches("C:\\USERS\\(.*?)\\downloads"));
    }
    
    ```
    
    - 플랫폼의 하위 클래스를 직접 지정해서 생성 → 이전에는 Platform의 current()를 통해 간접적으로 얻어내던 방식과 차이
    - 이렇게 하여 현 플랫폼에서 해당하는 경로 하나만 수행하던 문제를 극복
    

<br>

### 조건부 테스트

- 테스트 안에 숨겨진 조건 때문에 테스트의 이름이 의미하는 것과 다르게 동작하는 것을 말함
- 태스트 안의 조건문은 개발자를 오해하게 할 수 있는 나쁜 신호
    
    →실패해야 하는 상황인데, 성공할 수도 있고, 제대로 검증하고 성공해도, 디버거로 확인하기 전까지는 정말로 기대한 경로를 따라 실행된 것인지 확신 불가능
    
- **테스트 안에 조건절로 분기가 존재한다면, 분기별로 테스트하려는 시나리오와 동작이 다르다는 뜻이니 분기 각각을 독립된 테스트로 갈라놓는 것이 옳다**
