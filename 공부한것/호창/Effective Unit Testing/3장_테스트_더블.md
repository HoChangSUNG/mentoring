# 3장 테스트 더블

### 테스트 더블
- 테스트를 위해 진짜 객체를 대체하는 객체

### 테스트 더블을 활용하는 이유
- 기본적으로는 **테스트 대상 코드와 협력 객체를 분리(격리)하기 위해 사용**한다.

<br>

### 테스트 대상 코드를 격리한다는 것
- **테스트 대상 코드**와 **테스트 대상 코드와 상호작용하는 코드**로 **구분**하는 것을 말함

<br>

### 테스트 대상 코드를 격리할 때 장점 및 테스트 더블 존재 이유

1. **테스트 속도를 개선**
    - 테스트 더블을 이용해 미리 준비해둔 결과(테스트 더블이 준비한 결과)를 반환하도록 하면 시간이 줄어들어 테스트가 빨라질 수 있음
    - 하지만 엉뚱한 것을 테스트한다면 테스트 속도가 빨라도 별 도움이 되지 않음
2. **예측 불가능한 실행 요소를 제거**
    - 예측 불가능한 요인을 테스트 더블로 대체하여 항상 결정적인 테스트 결과(항상 동일한 결과)를 얻을 수 있게 됨
    - 예측 불가능한 실행 요소를 테스트 더블로 제거해서 테스트하려는 조건과 시나리오를 명확히 하는 이유는 결과에 영향을 주는 모든 요소를 결정적으로 만들기 위해서
    - 예시
        - 자동차 주행 경로를 테스트한다고 할 때 4시에 주행하는 경우와 차가 많이 막히는 6시에 주행한다고 하면, 시간에 따라 주행 경로 테스트 결과가 달라지게 된다.
        - 이렇게 되면 테스트하려는 조건에 따라 결과가 달라지게 되어 결정적으로 테스트를 만들지 못한다는 문제가 발생한다.
            
            여기서 **예측 불가능한 요인은 시간**이고, **시간을 테스트 더블로 대체**하여 항상 4시를 가르키게 한다면 항상 똑같은 시간을 알려주어 항상 동일한 테스트 결과가 나온다. 
            
3. **특수한 상황을 시뮬레이션한다**
    - 네트워크 연결 오류와 같은 에러는 **연결 요청을 처리하는 부분을 테스트 더블로 대체하여 예외를 발생**시킬 수 있다.
4. **감춰진 정보를 얻어낸다**
    - 테스트가 얻을 수 없었던 정보에 접근하기 위해서
    - 감춰진 정보를 얻어낸다는 것은 private 속성을 읽고 쓴다는 뜻보다는 **테스트 대상 코드와 협력 객체 사이의 상호작용을 확인하는 것**이다
    - 예시
        - Car와 Engine이 있다고 할 때, Car에 시동을 걸면 Engine이 가동한다. 실제로 Engine이 가동되었는지는 테스트 더블을 사용하지 않는다면 알 수 있는 방법이 없음
        - Car의 Engine을 테스트 더블로 교체하고 테스트 더블로 교체된 engine에 `isRunning()` 과 같은 테스트 전용 메서드를 추가
            
            → 테스트 전용 메서드는 테스트 코드에만 추가되고 제품 코드를 수정하지 않음(**테스트 전용 코드를 넣기 위해 제품 설계를 바꾸는 꺼림칙한 일 방지**)
            
        
        ```java
        public class Car{
        	private Engine engine;
        
        	public void start(){
        		engine.start()
        	}
        }
        
        public class CarTest{
        	@Test
        	public void engineIsStartedWhenCarStarts(){
        		TestEngine engine = new TestEngine(); // 테스트 더블
        		new Car(engine).start();
        		assertThat(engine.isRunning()); // TestEngine에만 선언되어 있음 -> 제품 코드에는 작성되어 있지 않음
        	}
        	
        	public class TestEngine extends Engine{
        		private boolean isRunning;
        		
        		public void start(){isRunning=true;}
        		public boolean isRunning(){return isRunning;}
        	}
        }
        ```
        

<br>
<br>

### 테스트 더블의 종류

1. **테스트 스텁** 
2. **가짜 객체** 
3. **테스트 스파이**
4. **Mock  객체**
    
    ![Untitled (5)](https://github.com/HoChangSUNG/mentoring/assets/76422685/1bcd90bc-03d9-415e-9785-3c444074c49b)

<br>

### 테스트 스텁

- 원래의 구현을 최대한 단순한 것으로 대체하는 것
- 예시
    - Logger와 상관없는 기능을 하는 경우 log() 메서드는 아무 일도 하지 않게 구현 → 로그와 관련 없는 기능을 검사하기 때문에 로그가 있는지조차 알 필요가 없음
    - 만약 로그의 level을 리턴하는 메서드가 존재한다면 level을 리턴하는 메서드는 하드 코딩된 값을 반환해야 한다
        
        ```java
        public class LoggerStub implements Logger{
        	public void log(LogLevel level,String message){
        		// 아무 일도 하지 않음
        	}
        	public void LogLevel getLogLevel(){
        		return LogLevel.WARN; //하드코딩된 값을 반환
        	}
        }
        ```
        
        - LogLevel.WARN를 반환하도록 하드 코딩했는데 잘못되었을까?
            - 진짜 Logger대신 테스트 스텁을 사용하는 데는 다음 3가지 이유가 있기 때문에 전혀 문제될 것이 없다
                1. 테스트는 대상 코드가 로깅하는 내용에는 전혀 관심이 없다
                2. 가동 중인 로그 서버가 없으니 로깅은 어차피 실패했을 것이다.
                3. 테스트 스위트가 콘솔로 대량의 정보를 쏟아내는 것은 바라지 않는다(파일에 쓰는건 별로 상관없다)

### 가짜 객체
- 진짜 객체의 행동을 흉내 내지만 진짜 객체를 사용할 때 생기는 부수 효과나 연쇄 동작이 일어나지 않도록 경량화하고 최적화한 것

### 테스트 스파이
- 어떻게 호출되었는지에 따라 일부 정보를 기록, 어떤 동작이 이루어졌는지 검증하는 용도

### Mock 객체
- 동작을 동적으로 재설정하거나 거대한 상호작용이 정말로 일어났는지 확인할 수 있도록 특화된 테스트 스파이
  
<br>
<br>

### 테스트 더블 활용 지침

1. **용도에 맞는 더블을 선택**
    - **테스트를 가장 읽기 쉽게 만들어주는 테스트 더블을 선택**해야 한다.
    - 선택 방법 → **스텁은 질문하고 Mock은 행동한다**
        - 두 객체 간 상호작용의 결과로 특정 메서드가 호출되었는지 확인하고 싶으면 → Mock 객체 써야 할 가능성이 높음
        - Mock 객체 사용하기로 했는데, 테스트 코드가 깔끔하게 정리되지 않으면 더 단순한 테스트 스파이를 작성해서도 똑같은 마술을 부릴 수 있는지 생각해보자
        - 협력 객체는 자리만 지키면 되고 협력 객체가 대상 객체에 넘겨줄 응답도 테스트에서 통제할 수 있다면 스텁이 정답이다
        - 필요한 서비스나 컴포넌트를 미처 준비하지 못해 스텁을 대용품으로 사용하는데, 시나리오가 너무 복잡해 벽에 부딪혔거나 테스트 코드가 관리하기 어려울만큼 복잡해졌다면 가짜 객체를 구현하는 걸 고려해보자
        - 이도 저도 아니라면 동전을 던져보자. 앞면이 Mock 객체, 뒷면이 스텁이다. 어쩌다 똑바로 서버리면 가짜 객체를 써도 뭐라 하지 않겠다.
 <br>

2. **단위 테스트 코드 구조를 준비-시작-단언으로 구성해라**
    - 준비-시작-단언 이라는 단위 테스트 구조에 관한 규약이 존재
        - 필요한 객체들을 준비하고, 실행하고, 단언하는 세 단계로 테스트를 구성하는 것
        - 3개의 영역 중 하나가 비대하다고 느껴지면 너무 많은 것을 검사하려는 테스트일 가능성이 높음 → 더 작은 단위의 기능을 집중저으로 검사하는 테스트로 나눌 필요가 있다는 신호
    - 행위 주도 개발 진영에는 given-when-then으로 구성함
        - (Given)주어진 상황에서 (When)어떤 일이 발생했을 때 (Then)특정 결과를 기대한다.
<br>

3. **구현이 아니라 동작을 확인하라**
    - 테스트는 오직 한 가지만 검사해야 하고 그 의도를 명확히 전달하도록 작성되어야 한다. 따라서 **테스트 대상 객체에서 검사하려는 동작(의도한 핵심 동작)은 무엇**이고 굳이 확인할 필요가 없는 **부수적인 구현은 무엇**인지를 찾아볼 필요가 있다
        - Mock에는 의도한 핵심 동작만 설정하고, 부수적인 구현은 호출 횟수에 전혀 개의치 않는 관대한 Mock 객체나 스텁만으로 충분
<br>

4. **자신의 도구를 선택하라**
    - Mock 객체 라이브러리를 선택할 때 중요한 것은 테스트 코드는 지금이나 앞으로도 읽기 쉽고 간결하고 관리가 쉬워야 한다.
    - Mockito는 **스텁**과 **검증**을 구분하는 특징을 가짐, 스텁을 주로 사용하는 테스트에서는 JMock보다 Mockito가 유리할 수 있음
    - JMock과 Mockito의 지향 방향
        - JMock의 테스트 더블(Mock 객체)은 대상 코드가 그 어떤 것도 자기 마음대로 호출하면 안된다고 믿는다. 이 가정을 완화하려면 스텁을 사용해야 한다
        - Mockito의 테스트 더블(Mock 객체)은 대상 코드가 언제건 아무것이나 호출해도 된다고 믿는다. 이 가정을 강화하려면 우리가 직접 메서드 호출 여부를 확인해야 한다.
<br>

5. **종속 객체를 주입하라**
    - 진짜 객체를 테스트 더블로 교체하기 위해 생성자 주입 방식을 이용해 종속 객체를 주입하는 방식을 많이 사용한다.

<br>
<br>

### 정리

테스트 대상 코드를 격리해야지 모든 시나리오를 시뮬레이션하고 모든 동작을 검증할 수 있기 때문에 이를 위해 테스트 더블을 사용한다
- **테스트 더블 사용 이유**
    - 테스트 시간을 단축 위해
    - 난수나 현재 시간 등 비결정적인 요소에 좌지우지되는 코드를 검사할 때 예측 불가능한 요소를 예측할 수 있게 바꾸기 위해
    - 특수한 상황을 시뮬레이션하기 위해
    - 테스트 전용 코드를 넣기 위해 제품 설계를 바꾸는 꺼림칙한 일 방지(감춰진 정보 얻어냄)

**테스트 스텁** → 불필요한 협력 객체를 쳐내는 데 가장 효과적  
**가짜 객체** → 진짜 객체가 사용하기 어렵거나 귀찮을 때 쓸 수 있는 대용품  
**테스트 스파이** → 본래에 접근할 수 없었던 내부 정보가 궁금할 때 사용하면 좋음  
**Mock 객체** → 동작을 동적으로 재설정하거나 거대한 상호작용이 정말로 일어났는지 확인할 수 있도록 특화된 테스트 스파이
