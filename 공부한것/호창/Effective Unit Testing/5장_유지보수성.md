# 5장 유지보수성

이 장에서는 **유지보수성을 떨어뜨리는 테스트 냄새와 이이 대한 개선 방법**을 알려준다.

## 테스트 냄새

- 중복
- 조건부 로직
- 양치기 테스트
- 파손된 파일 경로
- 끈질긴 임시 파일
- 잠자는 달팽이
- 픽셀 퍼펙션
- 파라미터화된 혼란
- 메서드 간 응집력 결핍

### 1. 중복

- 하나의 개념이 여러 차례에 걸쳐 표현되거나 복제된 것(필요 없는 반복)
- 중복이 나쁜 이유
    - 개념과 논리를 곳곳에 흩어놓아 코드를 이해하기 어렵게 하고, 코드 수정 시 중복된 곳을 모두 찾아 일일이 손봐야 하며, 한 곳이라도 놓치면 버그로 이어지기 때문이다.
- 종류
    - 상수 중복 : 같은 문자열이나 값들이 중복된 것
        - 지역 변수로 중복된 값들을 추출하여 제거
    - 구조 중복  : 데이터만 다르고 처리 로직이 똑같은 상황
        - 메서드로 추출하여 구조 중복을 제거
    - 의미 중복 : 같은 기능이나 개념을 다른 방식으로 구현한 것, 찾기 어려움
        - 의미 중복을 구조 중복으로 바꾸고, 변수나 메서드를 추출해 구조 중복을 제거하면 됨
- 가독성을 위해 일부러 중복을 남겨둬야 할 상황도 존재함
    - 테스트 코드에서 가장 중요한 목표는 코드를 읽기 쉽게 유지해 읽는 이에게 그 의도와 기능을 명확히 전달해야 하기 때문

### 2. 조건부 로직

- 코드가 해야 하는 일 혹은 해야 할 일을 파악하지 못하게 하고, 테스트 실패 원인을 파악하기 힘들게 함
    
    코드가 제대로 동작하지 않지만 동작하는 것처럼 테스트가 실행되기도 함
    
- 조건부 로직은 if, else, for, while과 같은 실행 구조를 말함
- 따라서 테스트 메서드는 조건부 로직을 가져서는 안되고, 테스트 대상의 동작이 복잡할수록 조건부 로직이 테스트 코드에 있지 않는 것이 더 중요해짐

### 3. 양치기 테스트

- 간헐적으로 실패하는 테스트, 테스트가 실패해서 빌드가 중단되었는데, 막상 다시 돌려보면 보란 듯이 통과해버리는 테스트
- 다음과 같은 경우에 자주 발생
    - 테스트가 경쟁상태를 일으키는 스레드를 사용
    - 현재 날짜나 시간에 따라 동작이 달라지는 경우
    - 입출력 속도나 테스트 실행 당시의 CPU 부하 등 컴퓨터의 성능에 영향을 받는 경우
- 해결 방법
    1. 회피 : 당면한 문제를 완전히 피해가는 것, 예를 들어 타임 스탬프 대신 파일명 뒤에 숫자를 붙여 정렬
    2. 제어 : 예를 들어 값을 원하는 순서로 반환하는 가짜 객체로 교체하는 방법
    3. 격리 : 격리하여 비결정적인 행동으로부터 해방

### 4. 파손된 파일 경로

- 코드를 움직이지 못하게 동여매어 개발자 컴퓨터 외에는 어디에서도 돌아가지 못하게 함
- 보통 파일 경로를 절대 경로로 했을 때 발생 → 다른 운영체제에서 실행할 경우 파일을 찾지 못함
- 해결 방법
    - 파일을 다룰 때 절대 경로는 무조건 피하고 상대 경로로 표현한다.
    - 파일을 스트림으로 대체하라 : FIle 클래스가 아니라 OutputStream, InputStreeam을 사용해라 → 인터페이스이기 때문에 테스트 더블로 교체가 쉬움
    - 프로젝트에 필요한 모든 자원은 프로젝트 루트 디렉터리 하위에 두는 것을 원칙으로 해라(끈질긴 임시 파일이 해당 원칙에 대한 예외가 됨)

### 5. 끈질긴 임시 파일

- 임시 파일이 임시적이지 않고 다음 테스트 수행 시까지도 지워지지 않고 존재하는 상황
    - 임시 파일 : 임시로 쓰기 위해 만들어서 다 쓰고 나면 삭제되는 파일
- 개선 방법
    1. @Before 메서드에서 파일을 삭제하라
        - 테스트가 실행되기 전에 매번 지워주는 것이 확실
    2. 가능하면 임시 파일명도 고유하게 지어라
        - 테스트 각각이 사용하는 파일 이름이 고유하다는 것이 보장되면 다른 테스트로 인해 만들어진 끈질긴 임시 파일에 시달릴 걱정이 없음
    3. 파일이 있어야 하는지를 명시하라
- 파일을 다루는 테스트의 문제 중 하나는 파일시스템이란 것이 모든 테스트가 공유하는 자원 → 테스트끼리 방해하는 상황이 발생 가능
- 가장 중요한 것은 테스트의 목적상 반드시 필요한 경우가 아니라면 절대로 파일을 사용하지 않는 것

### 6. 잠자는 달팽이

- 다른 스레드가 완료되기를 기다리느라 Thread.sleep() 으로 긴 시간을 허비한 후에 다음 단계를 실행하는 느린 테스트
    - 스레드 실행 속도와 스케쥴링 순서가 일정하지 않아 작업 스레드의 평균적인 완료 시간보다 훨씬 오래 쉬어야 함
- 느려터진 테스트는 유지보수 입장에서 치명적인 단점
- 해결 방법
    - 자바 표준 API의 동기와 객체인 CountDownLatch를 이용해 작업 스레드가 일을 마치는 즉시 알 수 있게 하여 잠자는 달팽이 문제를 해결

### 7. 픽셀 퍼펙션

- 그래픽스나 그래픽을 출력하는 코드를 검사하는 테스트가 풍기는 냄새
- 기본 타입 단언과 매직 넘버의 특수한 형태, 컴퓨터 그래픽스 분야에서 상당히 빈번하게 발견되는 냄새
- 기대한 것과 완벽하게 일치하는 이미지가 만들어졌는지 확인해야 하거나 생성된 이미지의 특정  픽셀이 원하는 색을 띠는지 확인하려는 테스트가 자주 냄새를 풍김
- 의미상으로는 상위 개념을 검사하면서도 실제로는 낮은 수준의 개념(점의 좌표와 색상 같은)을 그것도 하드코딩해서 검사하기 때문에 이해하기 어렵다.

### 8. 파라미터화된 혼란

- **파라미터화된 테스트**를 너무 과하게, 잘못된 상황에서 사용할 경우 생기는 테스트 냄새
- **파라미터화된 테스트**
- 입력값과 출력값만 다른 다수의 테스트가 반복되는 걸 간결하게 줄여주는 기법
- [사용법](https://dublin-java.tistory.com/56)
- 파라미터화된 테스트 패턴 적용시 문제
    1. 테스트 데이터가 한눈에 들어오지 않음
    2. 실패 시에 어느 테스트가 실패한 것인지 구분하기 어려움
- 파라미터화된 테스트 사용 시 부작용 최소화 방법
    1. 개별 데이터 집합을 시각적으로 구분하기 위해 각 데이터 집합을 메서드 호출로 감싸(set) 한눈에 데이터 집합이 보이도록 함
        
        ![Untitled](https://github.com/HoChangSUNG/mentoring/assets/76422685/bd628be6-e3bb-4cc7-aa9a-34a7d80eb1f0)

    2. 단언문의 오류 메시지를 이용해 데이터 집합만으로 실패한 테스트를 구분해주지 못하기 때문에 테스트 케이스가 사용하는 데이터 집합의 모든 값을 단언 메시지에 포함시키면 실패한 시나리오를 빠르게 알아낼 수 있음

### 9. 메서드 간 응집력 결핍

- 테스트 클래스 하나에 속한 테스트 메서드들이 서로 다른 픽스처 객체를 사용하는 것
- 이러한 테스트는 프로그래머가 필요 이상으로 많은 객체를 다뤄야 하고, 코드가 복잡해져 어느 테스트가 어느 픽스처 객체를 사용하는지, 셋업에서 어느 객체를 어떻게 설정해야 하는지 알기 어려움
    
    또한 다수의 테스트가 한 객체에 달려들어 사용하기 시작하면 적절한 그 객체에 이름을 지어 주기도 점점 어려워짐
    
- 해결방안
    - 모든 테스트가 같은 픽스처를 사용하도록 고쳐보면 메서드 간 응집력 결핍이 해결
    - 하지만, 복잡 다양한 픽스처 조합이 필연적이라 판단될 때 , 응집력 결핍 현상을 해결할 수 있는 방법 2가지
        1. 새로운 테스트 클래스를 만들어서 테스트 메서드 일부를 옮기고, 필요하다면 공통 로직을 담아둘 기반 클래스를 추출
        2. 별도의 클래스가 제공하는 유틸리티 메서드를 이용해서 테스트 메서드 각자가 필요한 픽스처를 직접 생성
