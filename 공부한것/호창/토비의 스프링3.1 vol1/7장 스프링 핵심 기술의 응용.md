# 7장 스프링 핵심 기술의 응용

## 7.1 SQL과 DAO의 분리

### **SQL과 DAO의 분리 이유**

- SQL 변경이 필요한 상황이 발생하면 SQL을 담고 있는 DAO 코드가 수정될 수밖에 없고, DAO 코드를 수정하고 이를 다시 컴파일해서 적용하는 것은 번거롭고 위험하기 때문

### **XML 설정을 이용한 분리**

- SQL을 스프링의 XML 설정파일로 빼내는 것
- 문자열로 되어 있는 SQL을 설정파일에 프로퍼티 값으로 정의해서 DAO에 주입
1. **개별 SQL 프로퍼티 방식**
    - SQL을 DAO의 설정 파일 부분에 프로퍼티로 추가
    - 매번 새로운 SQL이 필요할 때마다 프로퍼티를 추가하고 DI를 위한 변수와 수정자 메서드를 만들어줘야 한다는 단점
2. **SQL 맵 프로퍼티 방식**
    - SQL을 설정파일의 하나의 컬렉션에 담아두는 방법
    - Map을 이용해 프로퍼티는 하나만 만들고, sql이 더 필요하면 프로퍼티 추가 없이 설정파일의 맵 정보만 변경하면 됨
    - Map에서 key 값으로 sql 문장을 가져올 때 key값에 오타가 있어도, 실제로 실행되기 전까지는 오류를 확인하기 힘드다는 단점

### **SQL 제공 서비스를 통한 분리**

- XML 설정을 이용한 분리는 다음과 같은 문제가 존재
    1. SQL과 DI 설정정보가 섞여 있어 관리하기 힘듦
    2. 스프링의 설정파일로부터 생성된 오브젝트와 정보는 애플리케이션을 다시 시작하기 전에는 변경이 매우 어렵다는 점
- 이런 문제점을 해결하려면 DAO가 사용할 SQL을 제공해주는 기능을 독립시킬 필요가 존재 → **독립적인 SQL 제공 서비스**가 필요
- SQL 서비스의 인터페이스를 설계하고 SQL에 대한 키 값 전달 시 그에 해당하는 SQL을 돌려주는 구현체를 작성, DAO가 SQL 서비스 인터페이스를 DI 받아 사용
- **DAO에는 전혀 영향을 주지 않으면서 다양한 방법으로 SQL 서비스 인터페이스의 구현체 변경이 가능(장점)**

<br>
  
## 7.2 인터페이스 분리와 자기참조 빈

### **XML 파일 매핑**

- 스프링의 XML 설정 파일에 SQL 정보를 넣어놓고 활용하는 것보다는 SQL을 저장하는 전용 포멧을 가진 독립적인 파일을 사용하는 것이 바람직

### **JAXB**

- XML에 담긴 정보를 파일에서 읽어오는 방법 중 하나
- XML의 정보를 그대로 담고 있는 오브젝트 트리 구조를 만들어주기 때문에 XML 정보를 오브젝트처럼 다룰 수 있어 편리
    
    (DAO가 DB 테이블의 내용을 User라는 자바 오브젝트와 List 컬렉션으로 매핑해주는 것과 비슷)
    
- **JAXB에서의 언마샬링(unmarshalling)** : XML 문서를 읽어서 자바의 오브젝트로 변환하는 것
- **JAXB에서의 마샬링(marshalling)** : 바인딩 오브젝트를 XML 문서로 변환하는 것

### **JAXB를 이용하여 SQL 관련 내용을 스프링의 XML 설정 파일에서 분리**

- JAXB를 이용해 별도의 SQL 관련 XML을 이용하여 SQL문장을 스프링의 빈 설정에서 분리
- 독자적인 스키마를 갖는 깔끔한 XML 문서이므로 작성하고 검증하기에도 편리
- **SQL 내용을 변경하더라도 애플리케이션의 코드나 DI 설정은 전혀 수정할 필요가 업음**
    

### **JAXB를 이용하여 SQL 관련 내용을 스프링의 XML 설정 파일에서 분리 문제**

- 문제
    1. 생성자에서 예외가 발생할 수도 있는 복잡한 초기화 작업을 다루는 것
        - 생성자에서 발생하는 예외는 다루기 힘들고, 상속하기도 불편하고, 보안에도 문제가 생길 수 있음
    2. 읽어들일 파일의 위치와 이름이 코드에 고정되어 있다는 점
- 해결방법
    - 객체 생성 이후 초기화 작업을 호출
    - BUT, 생성된 오브젝트는 스프링 빈으로, 제어권이 스프링에 있어 **생성은 물론이고 초기화도 스프링에게 맡길 수밖에 없음**
    - 위 문제는 **@PostConstruct를 이용**해 스프링 빈 생성 이후, 초기화 작업을 가능하게 해줌

### **@PostConstruct**

- 빈 오브젝트를 생성하고 DI 작업을 마친 뒤에 @PostConstruct가 붙은 메소드를 자동으로 실행하도록 하는 빈 후처리기
- 빈 생성 이후 빈의 초기화를 가능하게 해줌
- 스프링 컨테이너 초기 작업 순서
    ![Untitled (3)](https://github.com/HoChangSUNG/mentoring/assets/76422685/b540e9d8-390d-4b2f-9b7f-73ea76e2c5f0)


**XmSqlService를 인터페이스를 이용한 분리**

- 문제 : 하나의 클래스에 여러 개의 책임이 존재
    - SQL 정보를 외부의 리소스로부터 읽어오는 것(외부 리소스 → 텍스트 파일, XML, 엑셀 파일….)
    - 읽어온 SQL을 보관해두고 있다가 필요할 때 제공해주는 것(Map, db …..)
- 해결 방법
    - 책임을 분리 → SqlReader와 SqlRegistry 인터페이스
        - SqlReader : SQL 정보를 외부의 리소스로부터 읽어오는 기능
        - SqlRegistry : 읽어온 SQL을 보관해두고 있다가 필요할 때 제공해주는 기능
    - SqlService의 구현 클래스가 변경 가능한 책임을 가진 SqlReader와 SqlRegistry 두 가지 타입의 오브젝트를 사용하도록 함
        - 인터페이스를 이용하고 DI를 통해 의존 오브젝트를 제공받게 함
        ![Untitled (4)](https://github.com/HoChangSUNG/mentoring/assets/76422685/25b10ab6-fd1b-4fdb-9a08-cb308b15ebe2)

    - 위에서 SqlService가 SqlReader를 통해 SQL 읽기 요청을 보낸 결과를 SqlRegistry에 보내는 것은 아래와 같은 코드로 나타남
        
        ```java
        Map<String,String> sqls = sqlReader.readSql();
        sqlRegistry.addSqls(sqls);
        ```
        
        - **위 코드의 문제점인 구현 방식이 다양한 두 개의 오브젝트 사이에서 복잡한 정보를 전달하기 위해 전달 과정 중 일정한 포맷으로 변환하도록 강제하는 것은 피할 수 없을까?**
        
    - 아래와 같이 변경하여 **일정한 포맷으로 변환하는 문제를 해결**할 수 있다
        
        ```java
        sqlReader.readSql(sqlRegistry); -> SQL을 저장할 대상인 sqlRegisty 오브젝트를 전달
        ```
        
        - 구조
          
            ![Untitled (5)](https://github.com/HoChangSUNG/mentoring/assets/76422685/670aea10-dd49-48d9-9b38-dba46de4c4b4)

            - 위처럼 하면, SqlReader와 SqlRegistry는 각자의 구현 방식을 독립적으로 유지하면서 꼭 필요한 관계만 가지고 협력해서 일을 할 수 있는 구조가 됨
            - SqlReader가 사용할 SqlRegistry 오브젝트를 제공해 주는 건 SqlService의 코드가 담당
                - SqlRegistry가 일종의 콜백 오브젝트처럼 사용됨
            - SqlReader 입장에서는 SqlRegistry 인터페이스를 구현한 오브젝트를 런타임 시에 메소드 파라미터로 제공받아 사용하는 구조이기 때문에 일종의 코드에 의한 수동 DI라고 볼 수 있음
        

### **자기 참조 빈 사용**

- 빈의 참조가 자신 자신을 가리키는 것
- 같은 클래스의 코드이지만 책임이 다른 코드는 인터페이스로 분리하여, 직접 접근하지 않고 인터페이스를 통해 간접적으로 사용하도록 함
    
    ![Untitled (6)](https://github.com/HoChangSUNG/mentoring/assets/76422685/9931f502-acbc-4890-8c1c-0fba2b3720b9)


- SqlService의 메소드에서 Sql을 읽을 때는 SqlReader 인터페이스를 통해, SQL을 찾을 때에는 SqlRegistry 인터페이스를 통해 간접적으로 접근
    - SqlReader를 구현한 코드에서 XmlSqlService 내의 다른 변수와 메소드를 직접 참조하거나 사용하면 안됨. → 필요한 경우 적절한 인터페이스로 접근
    - SqlRegistry를 구현한 코드에서 XmlSqlService 내의 다른 변수와 메소드를 직접 참조하거나 사용하면 안됨. → 필요한 경우 적절한 인터페이스로 접근
    
     **→ 서로 다른 책임을 인터페이스로 분리하고, 서로 다른 책임과 관련된 코드는 직접 참조하거나 사용하지 않고, 인터페이스를 통해 접근**
    

- 자기 자신을 참조하는 빈은 흔히 쓰이지는 않고, 책임이 다르다면 클래스를 구분하고 각기 다른 오브젝트로 만들어지는 것이 자연스러움
    
    **다만 자기 참조 빈을 만들어 보는 것은 책임과 관심사가 복잡하게 얽혀 있어 확장이 힘들고 변경에 취약한 구조의 클래스를 유연한 구조로 만들려고 할 때 처음 시도해볼 수 있는 방법**
    
    이를 통해 기존의 복잡하게 얽혀 있던 코드를 책임을 가진 단위로 구분해낼 수 있음
    

### **디폴트 의존 관계를 갖는 빈**

- **디폴트 의존 관계** : 외부에서 DI 받지 않는 경우 기본적으로 자동 적용되는 의존관계
    - 특정 의존 오브젝트가 대부분의 환경에서 거의 디폴트라 해도 좋을 만큼 기본적으로 사용될 가능성이 있다면, 디폴트 의존관계를 갖는 빈을 만드는 것을 고려해볼 필요 있음
- DefaultSqlService(미리 설정된 디폴트 의존 오브젝트를 갖는 클래스)는 SqlService를 바로 구현한 것이 아니라, BaseSqlServicee를 상속하여, BaseSqlService의 sqlReader와 sqlRegistry 프로퍼티는 그대로 갖고 있고, 이를 이용해 원한다면 언제든 일부 또는 모든 프로퍼티를 변경할 수있다.
    
    디폴트 의존 오브젝트 대신 사용하고 싶은 구현 오브젝트가 있다면, 설정 정보에 추가하여 통해 DI 받으면 된다. 
    
<br>

## 7.3 서비스 추상화 적용

### **OXM 서비스 추상화**

- OXM : XML과 자바 오브젝트를 매핑해서 상호 변환해주는 기술
- OXM 기술들은 기능 면에서 상호 호환성이 있고, 모두 사용 목적이 동일하여 유사한 기능과 API를 제공한다
    
    **즉,OXM 서비스를 추상화할 수 있다는 것이다.**
    
- Unmarshaller,Marshaller 인터페이스로 OXM 서비스를 추상화하고, 이를 적용
- **서비스 추상화를 통해 로우 레벨의 기술을 필요에 따라 변경하여 사용해도 일관된 애플리케이션 코드를 유지할 수 있게 해줌**

### **OXM 서비스 추상화 적용**

![Untitled (7)](https://github.com/HoChangSUNG/mentoring/assets/76422685/1100c4f7-7deb-41ba-9062-e8d0ea5064a8)

- SqlReader 타입의 의존 오브젝트를 사용하되 이를 OxlSqlService의 static 멤버 클래스로 내장하고 자신만 사용할 수 있도록, 의존 오브젝트를 자신만이 사용하도록 하는 독점 구조로 만드는 방법
    - 내장된 SqlReader 구현체를 외부에서 사용하지 못하도록 제한하고 스스로 최적화된 구조로 만들어두는 것
- 밖에서는 하나의 오브젝트로 보이지만(OxmlSqlService) 내부에서는 의존관계를 가진 두 개의 오브젝트가 결합되서 사용
    - **위 사진 예시 코드**
        
        ```java
        public class OxmSqlService implements SqlService{
        	private final OxmSqlReader oxmSqlReader = new OxmSqlReader();
        	
        	private SqlRegistry sqlRegistry = new HashMapSqlRegistry();
        	public void setSqlRegistry(SqlRegistry sqlRegistry){this.sqlRegistry = sqlRegistry;}
        	
        	public void setUnmarshaller(Unmarshaller unmarshaller){...}
        	public void setSqlmapFile(String sqlmapFile){ ... }
        
        	@PostConstruct
        	public void loadSql(){ this.oxmSqlReader.read(this.sqlRegistry);}
        
        	public String getSql()throws SqlRetrievalFailureException{
        		try{return sqlRegistry.findSql(key);}
        		catch(SqlNotFoundException e){throw new SqlRetrevalFailureException(e);}
        	}
        
        	private class OxmSqlReader implements SqlReader{
        		private Unmarshaller unmarshaller;
        		private final static String DEFAULT_SQLMAP_FILE = "sqlmap.xml";
        		private String sqlmapFile = DEFAULT_SQLMAP_FILE;
        
        		public void setUnmarshaller(Unmarshaller unmarshaller){...}
        		public void setSqlmapFile(String sqlmapFile){...}
        	
        		public void read(SqlRegistry sqlRegistry){
        			try{
        				Source source = new StreamSource(
        					UserDao.class.getResourceAsStream(this.sqlmapFile));
        				Sqlmap sqlmap = (Sqlmap)this.unmarshaller.unmarshal(source);
        				for(SqlType sql : sqlmap.getSql()){
        					sqlRegistry.registerSql(sql.getKey(), sql.getValue());
        				}
        			}catch(IOExpcetion e){
        				throw new IllegalArgumentException(this.sqlmapFile + "을 가져올 수 없습니다.",e);
        			}
        		}
        	}
        }
        
        ```
        
- **위처럼 두 개의 클래스를 강하게 결합하고 더 이상 확장이나 변경을 제한해두는 이유는?**
    - OXM을 이용하는 서비스 구조로 최적화하기 위해 → 하나의 클래스로 만들어두어 빈 등록과 설정은 단순해짐
    - 서비스를 개발하는 입장(SqlService를 개발하는 입장)에서는 가능한 한 분리하고 유연하게 확장할 수 있게 만드는 것이 중요하지만,
        
        실제로 이를 적용하여 개발하는 애플리케이션 개발자 입장에서는 서비스를 사용하기 위해 많은 빈을 등록하는 게 부담이 될 수 있음
        

### **위임을 이용한 BaseSqlService 재사용**

- 문제 : 초기화하는 부분(`loadSql(), getSql()`)이 OxmSqlService와 BaseSqlService가 중복된다는 점
    - `loadSql(), getSql(`)의 작업이 복잡하고 코드의 양이 많고 변경이 자주 일어나면, 이 중복은 심각한 문제가 될 수 있음
- 해결 방법 : 위임 구조를 이용해 코드의 중복을 제거
    - OxmSqlService의 외형적인 틀은 유지한 채로 SqlService의 기능 구혀은 BaseSqlService로 위임
    - 그렇다면 **이 문제를 프록시로 해결할까?** → **여러 타깃에 적용할 것도 아니고, 위임 구조를 위해 빈 두개를 등록하는 것은 불편**
    - 따라서 **OxmSqlService와 BaseSqlService를 한 클래스로 묶는 방법으로 해결**
        
        ![Untitled (8)](https://github.com/HoChangSUNG/mentoring/assets/76422685/c933150b-75f1-41ab-93a3-54398531d0c6)

        - OxmSqlService는 OXM 기술에 특화된 OxmSqlReader를 멤버로 내장하고 있고, 그에 필요한 설정을 한번에 지정할 수 있는 확장 구조만 가지고 있음
        - 실제 SqlReader와 SqlRegistry를 이용해 SqlService 기능을 구현하는 일은 OxlSqlService내부에 BaseSqlService를 만들어서 위임
        - **코드**
            
            ```java
            public class OxmSqlService implements SqlService{
            	private final BaseSqlService baseSqlService = new BaseSqlService();
            	// SqlService의 실제 구현 부분을 위임할 대상(BaseSqlService)을 인스턴스 변수로 정의
            	...
            
            	@PostConstruct
            	public void loadSql(){
            		this.baseSqlService.setSqlReader(this.oxmSqlReader);
            		this.baseSqlService.setSqlRegistry(this.sqlRegistry);
            		// OxmSqlService의 프로퍼티를 통해 초기화된 reader와 registry를 실제 작업을 위임할 대상인 baseSqlService에 주입
            		this.baseSqlService.loadSql();
            		// SQL 등록하는 초기화 작업을 baseSqlService에 위임
            	}
            	
            	public String getSql(String key) throws SqlRetrievalFailureException{
            		return this.baseSqlService.getSql(key); // SQL 찾아오는 작업도 baseSqlService에 위임
            	}
            }
            ```
            
        
    
    ### **리소스 추상화**
    
    - 다양한 위치에 존재하는 리소스에 대한 단일화된 접근 인터페이스인 Resource 인터페이스를 제공
    - ResourceLoader를 이용해 Resource 인터페이스 타입의 오브젝트로 전달
        - 문자열로 정의된 리소스를 ResourceLoader를 이용해 Resource 타입의 오브젝트로 변환하여 제공
        - 문자열 안에는 리소스 종류와 리소스 위치를 함께 표현
            - `file:/C:/temp/file.txt`
            - `classpath:file.txt`
        - 예시
            - 스프링의 애플리케이션 컨텍스트
                - ResourceLoader 인터페이스를 상속하고 있음, 애플리케이션 컨텍스트가 사용할 스프링 설정정보가 담긴 XML 파일도 리소스 롣를 이용해 Resource 형태로 읽어옴
    - **리소스 추상화를 통해 리소스의 위치와 접근 방법에 대한 독립적인 코드를 만들 수 있다
  
<br>

## 7.4 인터페이스 상속을 통한 안전한 기능 확장

### **인터페이스를 사용하는 이유**

1. 다형성을 얻기 위해
    - 하나의 인터페이스를 통해 여러 개의 구현을 바꿔가면서 사용할 수 있게 해주는 것
2. 인터페이스 분리 원칙을 통해 클라이언트와 의존 오브젝트 사이의 관계를 명확히 해줄 수 있기 때문
    - A가 B를 사용할 때, A가 B와 B1인터페이스를 통해 연결되어 있다고 한다면, A가 B를 바라볼 때 해당 인터페이스(B1)라는 창을 통해서만 본다는 뜻
    - 이때 B는 B2라는 다른 인터페이스를 구현하고 있을 수 있다. 그 이유는 B2 인터페이스라는 창으로 B를 바라보는 A와 다른 다른 종류의 클라이언트가 존재하기 때문이다.
    - **하나의 오브젝트가 여러 인터페이스를 구현할 수 있으므로, 하나의 오브젝트를 바라보는 창이 여러가지일 수 있다.**
        
        **즉, 각기 다른 관심과 목적을 가지고 어떤 오브젝트에 의존하고 있을 수 있다는 의미** 
        

### **인터페이스 상속**

- 오브젝트의 기능이 발전하는 과정에서 다른 종류의 클라이언트가 등장으로 인해 인터페이스를 여러 개 만드는 방식을 사용하는데, 때때로  **기존 인터페이스를 상속**하여 확장하는 방법도 사용된다.
- **인터페이스 분리 원칙 장점**
    1. 모든 클라이언트가 자신의 관심에 따른 접근 방식을 불필요한 간섭 없이 유지할 수 있다는 점
        - 기존 클라이언트는 자신이 사용하던 인터페이스를 통해 동일한 방식으로 접근할 수만 있다면 오브젝트의 변경에 영향을 받지 않음
        - 따라서 기존 클라이언트에 영향을 주지 않은 채로 오브젝트의 기능을 확장하거나 수정 가능
    2. 인터페이스 구현 오브젝트가 다른 제 3의 클라이언트를 위한 인터페이스를 가질 수 있다는 점

### **인터페이스 상속 예시**

![Untitled (9)](https://github.com/HoChangSUNG/mentoring/assets/76422685/73e49213-67b1-4c87-a4a4-4c6375bf73ea)

- 위 기존의 확장 구조에서는 SqlRegistry는 초기에 새로운 SQL을 등록하는 기능과 등록된 SQL을 조회하는 기능만 가지고 있다.
    
    **하지만 중간에 SQL을 변경해야 하는 기능이 추가된다면 어떻게 해야 할까?**
    
- 아래 그림과 같이 기존 SqlRegistry 인터페이스를 상속하고, 메소드를 추가한 새로운 인터페이스(UpdatableSqlRegistry)를 정의하면 된다.
    
    BaseSqlService는 초기화를 통한 SQL 등록 및 조회만을 목적으로 SqlRegistry 오브젝트를 사용하므로, **기존의 SqlRegistry 인터페이스를 통해 접근**하게 한다
    
    반면에 중간에 SQL 업데이트 작업이 필요한 새로운 클라이언트 오브젝트는 **UpdatableSqlRegistry 인터페이스를 통해 접근**하게 한다.  
    
- **인터페이스 상속을 이용한 확장 구조**
  
    ![Untitled (10)](https://github.com/HoChangSUNG/mentoring/assets/76422685/17a2516a-1137-4a91-a68c-e10f4de15183)
    
- 오브젝트 의존관계로 보면, DI를 통해 동일한 오브젝트를 의존하고 있지만, 설계와 코드에서는 각각 SqlRegistry, UpdatableSqlRegistry라는 서로 다른 인터페이스에 의존하고 있다.
    
    **즉, 관심과 필요에 따라 동일한 오브젝트를 다른 인터페이스를 통해 접근하고 있다.**
