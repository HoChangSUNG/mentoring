## 6.1 트랜잭션 코드의 분리

### 메소드 분리

- **문제** : 트랜잭션 경계설정 코드와 비즈니스 코드가 같은 메소드에 존재
- **해결 방법** : 비즈니스 로직을 메소드로 추출해 트랜잭션 경계설정 코드에서 분리
    - 비즈니스 로직, 트랜잭션 경계 설정 코드는 성격이 다르고, 서로 주고받는 것도 없는 완벽하게 독립적인 코드라 분리가 가능

### **DI를 이용한 클래스로 분리**

- **문제** : 트랜잭션을 담당하는 코드가 서비스 클래스 안에 존재(성격이 다른 코드가 분리되어 있지 않음)
- **해결 방법**
    - DI를 사용하여 실제 사용할 오브젝트 클래스를 감추고 인터페이스를 통해 간접적으로 접근하도록 함, 프록시 패턴을 사용하여 해결
    - UserService 인터페이스를 만들고, 비즈니스 로직을 담은 UserService 구현체(**UserServiceImpl**), 트랜잭션 경계 설정 책임을 맡고 있는 또 다른 UserService 구현체(**UserServiceTx**)를 만든다
        
        트랜잭션 경계 설정 책임을 맡고 있는 클래스에서 비즈니스 로직을 담고 있는 UserService 구현체에 실질적인 로직 처리 작업을 위임하는 방식
        
        그 위임을 위한 호출 작업 이전과 이후에 트랜잭션 경계 설정을 해서 클라이언트 입장에서 볼때 결국 트랜잭션이 적용된 비즈니스 로직의 구현이라는 기대하는 동작이 일어남
        
- **실제 동작**
    - 클라이언트가 UserService라는 인터페이스를 통해 사용자 관리 로직을 이용하려 할 때 **트랜잭션을 담당하는 오브젝트가 사용되어 트랜잭션 관련 작업을 진행(UserServiceTx)**하고,
        
        **실제 사용자 관리 로직을 담은 오브젝트가 이후에 호출되어 비즈니스 로직에 관련된 작업을 수행(UserServiceImpl)**하도록 만듦
        
    
    ![Untitled](https://github.com/HoChangSUNG/mentoring/assets/76422685/ad0dfdd7-c19c-4386-ab88-17f6d09e1b0e)

    ![Untitled (1)](https://github.com/HoChangSUNG/mentoring/assets/76422685/c1c1ee88-5a5b-494b-9e12-60cac93500a6)

- **트랜잭션 경계설정 코드 분리의 장점**
    1. 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다.
    2. 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다. → 트랜잭션 경계 설정 코들를 비즈니스 로직과 서로 다른 클래스로 분리시켰기 때문

<br>

## 6.2 고립된 단위 테스트

### 작은 단위 테스트가 좋은 이유

- 테스트가 실패했을 때 그 원인을 찾기 쉽기 때문
- 테스트 단위가 작으면 테스트의 의도나 내용이 분명해지고, 만들기도 쉬워짐

### 테스트 대상 오브젝트 고립

- 테스트 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 존재
- 테스트를 의존 대상으로부터 분리해서 고립시키는 방법은 **테스트 대역**을 사용하여 고립시킴
- upgradeLevels() 메소드를 테스트할 때 userDao는 스텁이 아니라 mock으로 만들어야 하는 이유
    - dao를 통해 필요한 정보를 가져오고, 작업을 수행한 후 db에 반영하는데 userDao라는 협력 오브젝트와의 상호작용의 결과를 저장해두고, 테스트의 검증에 이 상호작용의 결과를 사용할 수 있어야 하기 때문
    

### 단위 테스트와 통합 테스트

- 단위 테스트 : 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트하는 것
- 통합 테스트 :  두개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 → 두 개 이상의 단위가 결합해서 동작하면서 테스트가 수행되는 것
- 단위 테스트와 통합 테스트는 어떤 경우에 사용해야 할까?(가이드 라인)
    1. 항상 단위 테스트를 먼저 고려한다
    2. 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다.
        - DAO는 DB까지 연동하는 테스트로 만드는 것이 효과적
            - DB를 사용하는 테스트는 DB에 테스트 데이터를 준비하고, DB에 직접 확인 하는 등 부가적인 작업이 필요
    3. DAO를 통합 테스트로 충분히 검증하면, DAO를 이용하는 코드에서 DAO를 테스트 스텁이나 목 오브젝트로 대체해서 테스트한 결과가 이후 실제 DAO와 연동했을 때도 바르게 동작한다고 확신할 수 있다.
    4. 단위 테스트를 충분히 거쳤다면 통합 테스트의 부담이 상대적으로 줄어듦
    5. 단위 테스트를 만들기 너무 복잡하다고 판단되는 코드는 처음부터 통합테스트를 고려
        - 통합 테스트에 참여하는 코드 중에서 가능한 한 많은 부분을 미리 단위 테스트로 검증해두는 것이 유리

### 목 프레임워크

- MOCK 오브젝트를 편리하게 작성하도록 도와주는 프레임워크
    1. 테스트에서 사용하지 않는 인터페이스도 모두 일일이 구현해주어야 함
    2. 검증 기능이 있는 목 오브젝트를 만들기 위해서는 메소드의 호출 내용을 저장했다가 이를 다시 불러와야 하는 귀찮은 점
    3. 테스트 메서드별로 다른 검증 기능이 필요할 경우, 같은 의존 인터페이스를 구현한 여러 개의 목 클래스를 선언해줘야 한다. 

<br>

## 6.3 다이내믹 프록시와 팩토리 빈

### 프록시

- 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것
    
    ![Untitled (2)](https://github.com/HoChangSUNG/mentoring/assets/76422685/92540923-9562-49c3-8325-2f71cbfcbae1)

- **target(타깃)**
    - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트
- **특징**
    - target과 같은 인터페이스를 구현
    - 프록시가 타깃을 제어할 수 있는 위치에 있다는 것
- **프록시의 역할**
    - **위임**과 **부가작업**
- **사용 목적에 따라 디자인 패턴에서는 다른 패턴으로 구분**
    - 클라이언트가 타깃에 접근하는 방법을 제어하기 위해 → 프록시 패턴
    - 타깃에 부가적인 기능을 부여해주기 위해 → 데코레이터 패턴
    

### 데코레이터 패턴

- 타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴
    - 다이나믹하게 기능을 부여한다는 의미 : 컴파일 시점에는 어떤 방법과 순서로 프록시와 target이 연결되어 사용되는지 정해져 있지 않다는 뜻
- 각각의 데코레이터는 위임하는 대상에도 인터페이스로 접근하여 자신이 최종 타깃으로 위임하는지, 아니면 다음 단계의 데코레이터 프록시로 위임하는지는 알지 못함
- 예시
    - InputStream과 OutputStream 구현 클래스
    - UserService 인터페이스를 구현한 타깃인 UserServiceImpl에 트랜잭션 부가기능을 제공해주는 UserServiceTx를 추가한 것도 데코레이터 패턴을 적용한 예시

### 프록시 패턴

- 타깃에 대한 접근 권한을 제어하려는 목적으로 프록시를 사용하는 패턴
- 사용하는 시기
    1. 타깃 오브젝트의 생성을 늦춰야 하는 경우
        - 타깃 오브젝트를 생성하기 복잡하거나 당장 필요하지 않은 경우 꼭 필요한 시점까지 오브젝트 생성을 미룸
        - 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데, 실제 타깃 오브젝트를 만드는 대신 프록시를 넘겨주고, 타깃이 필요한 시점에 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 방식
    2. 원격 오브젝트를 이용하는 경우
        - 원격 오브젝트에 대한 프록시를 만들어두고, 클라이언트는 마치 로컬에 존재하는 오브젝트를 쓰는 것처럼 프록시를 사용
    3. 특별한 상황에서 타깃에 대한 접근권한을 제어하기 위한 경우
        - 수정 가능한 오브젝트가 있는데, 특정 레이어로 넘어가서는 읽기 전용으로만 동작하게 강제해야 하는 경우
        - ex) Collections의 unmodifiableCollections() → 파라미터로 전달된 Collection 오브젝트의 프록시를 만들어서 add()나 remove() 같이 정보를 수정하는 메소드를 호출할 경우 UnsupportedOperationException 예외가 발생하게 해줌

### 리플랙션

- 자바의 코드 자체를 추상화해서 접근하도록 만든 것
- 클래스 오브젝트를 이용하면 클래스 코드에 대한 메타정보를 가져오거나 오브젝트를 조작할 수 있다.

### 다이나믹 프록시(jdk 프록시)

- 프록시 팩토리에 의해 런타임 시 다이나믹하게 만들어지는 오브젝트
- 프록시 팩토리에게 인터페이스 정보만 제공해주면 해당 인터페이스를 구현한 클래스의 오브젝트를 자동으로 만들어줌 + 프록시에서 필요한 부가기능은 InvocationHandler를 구현한 오브젝트에 담아야 함
- 다이나믹 프록시는 다음과 같이 프록시를 만들기 번거로운 이유를 해결
    1. 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 번거로움
        - 부가 기능이 필요없는 메소드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어줘야 함
    2. 하나의 클래스 내의 메소드들에 부가기능 코드가 중복될 가능성이 많다는 점
        - 트랜잭션 부가 기능은 db를 사용하는 대부분의 로직에 필요하다. 만약  dao에서 트랜잭션 부가 기능이 필요한 메서드가 필요하다면, 트랜잭션 부가 기능을 제공하는 유사한 코드가 여러 메서드에 중복되서 나타남
- 동작 방식
    
    ![Untitled (3)](https://github.com/HoChangSUNG/mentoring/assets/76422685/ad5e3a9a-9d91-4e18-a75d-b08b162ddba6)

    1. 프록시 요청 시 인터페이스의 모든 메서드를 구현한 오브젝트를 생성
    2. 메소드 호출 시 모든 메소드 호출 요청을 InvocationHandler의 invoke() 메소드로 전달하여 메소드 처리를 요청한다.
        
        (다이나믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 InvocationHandler 구현 오브젝트로 넘기는 것)
        
    3. InvocationHandler의 invoke()에서 다이나믹 프록시로부터 전달받은 요청을 타깃 오브젝트의 메소드를 호출하여 위임한다.
        
        (다이나믹 프록시를 통해 요청이 전달되면 리플랙션 API를 이용해 타깃 오브젝트의 메소드를 호출)
        
- 사용법
    
    ```java
    Hello proxiedHello = (Hello)Proxy.newProxyInstance(
    	getClass().getClassLoader(), -> **클래스 로더 제공 : 다이나믹 프록시가 정의되는 클래스 로더를 지정**
    	new Class[]{Hello.class}, -> **다이나믹 프록시가 구현해야 할 인터페이스**
    	new UppercaseHandler(new HelloTarget()) -> **부가기능과 위임 관련 코드를 담고 있는 InvocationHandler 구현 오브젝트 제공**
    );
    ```
    
- 장점
    1. 다이나믹 프록시를 생성해서 사용하는 코드는 메서드가 추가되어도 수정하지 않아도 됨
        - 다이나믹 프록시가 생성될 때 추가딘 메서드가 자동으로 포함되고, 부가 기능은 invoke() 메서드에서 처리되기 때문
    2. 타깃의 종류에 상관없이 적용이 가능하다는 점
        - InvocationHandler는 리플랙션의 Method 인터페이스를 사용하여 타깃의 메소드를 호출하는 것이라 호출할 타깃의 타입을 제한할 필요가 없음
<br>

### 다이나믹 프록시를 위한 팩토리 빈(jdk 프록시)

- **다이나믹 프록시 오브젝트는 일반적인 스프링의 빈으로는 등록할 방법이 없음**
    - 스프링은 내부적으로 리플랙션 API를 이용해 빈 정의에서 나오는 클래스 이름을 가지고 빈 오브젝트를 생성한다
    - 문제는 다이나믹 프록시 오브젝트의 클래스가 어떤 것인지도 알 수 없고, 클래스 자체도 내부적으로 다이나믹하게 새로 정의해서 사용한다
    - 따라서 사전에 프록시 오브젝트의 클래스 정보를 미리 알아내서 스프링 빈에 정의할 방법이 없음
- **팩토리 빈을 이용해 다이나믹 프록시 오브젝트를 스프링 빈에 등록 가능**
    - 팩토리 빈 : 스프링을 대신해 오브젝트의 생성 로직을 담당하도록 만들어진 특별한 빈
        - 스프링의 FactoryBean이라는 인터페이스를 구현하여 팩토리 빈을 만들 수 있음
    - 스프링은 FactoryBean 인터페이스를 구현한 클래스가 빈의 클래스에 지정되면, 팩토리 빈 클래스의 오브젝트의 getObject() 메소드를 이용해 오브젝트를 가져오고, 이를 빈 오브젝트로 사용
        - 팩토리 빈의 getObject()에 다이나믹 프록시 오브젝트를 만들어주는 코드를 넣으면 팩토리 빈을 사용해 다이나믹 프록시 오브젝트를 스프링의 빈으로 만들어줄 수 있음
            
            ![Untitled (4)](https://github.com/HoChangSUNG/mentoring/assets/76422685/a61f0a3f-b055-4f98-8b67-6dd1c2c32656)

        

### 프록시 팩토리 빈 방식의 장점과 한계

- **장점**
    1. 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거
    2. 부가기능 코드의 중복 문제 해결
        - 하나의 핸들러 메소드를 구현하는 것만으로도 수많은 메소드에 부가기능을 부여해줄 수 있어서
- **한계**
    - 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공하는 것은 불가능
        - 하나의 클래스 안에 존재하는 여러 개의 메소드에 부가기능을 한 번에 제공하는 것은 가능
    - 하나의 타깃에 여러 개의 부가기능을 적용하려면 설정 파일이 복잡해짐
    - InvocationHandler 오브젝트가 프록시 팩토리 빈 개수만큼 만들어진다

<br>

## 6.4 스프링의 프록시 팩토리 빈

### ProxyFactoryBean

- 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈
- JdKProxy와 달리 ProxyFactoryBean은 프록시를 생성하는 작업만 담당하고 부가기능은 MethodInterceptor 인터페이스를 구현한 객체에 별도의 빈으로 둔다.
- MethodInterceptor와 InvocationHandler 차이
    - InvocationHandler → invoke() 메서드에 타깃 오브젝트에 대한 정보를 제공하지 않음
    - MethodInterceptor → invoke() 메서드에 타깃 오브젝트에 대한 정보를 제공받음
        - 이 덕분에 MethodInterceptor가 타깃 오브젝트에 상관없이 독립적으로 만들어질 수 있고, 타깃이 다른 여러 오브젝트에서 함께 사용될 수 있고, 싱글톤으로 등록이 가능
        - 즉, 어드바이스(MethodInterceptor)는 MethodInvocation이 타깃을 호출하는 기능을 가지는 콜백 오브젝트로 제공되어 특정 타깃에 의존하지 않고 재사용이 가능

### 예시

```java
@Test
public void proxyFactoryBean(){
	ProxyFactoryBean pfBean = new ProxyFactoryBean();
	pfBean.setTarget(new HelloTarget()); // 타깃 설정
	pfBean.addAdvice(new UppercaseAdvice()); // 부가 기능을 담은 어드바이스를 추가, 여러개 추가 가능
	Hello proxiedHello = (Hello)pfBean.getObject();// FactoryBean이므로 getObject()로 생성된 프록시를 가져옴
}
static class UppercaseAdvice implements MethodInterceptor{
	public Object invoke(MethodInvocation invocation)throws Throwable{
		String ret = (String)invocation.proceed(); 
		// 실행시 타깃 오브젝트를 전달할 필요x, 
		// MethodInvocation은 메소드 정보와 함께 타깃 오브젝트를 알고 있기 때문 
		return ret.toUpperCase(); // 부가 기능 적용
	}
}
```

**ProxyFactoryBean은 어떻게 인터페이스 타입을 제공받지 않아도 구현해야 할 인터페이스를 만들 수 있을까?**

- ProxyFactoryBean에 있는 인터페이스 자동검출 기능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아낼 수 있기 때문

**JDK 다이나믹 프록시를 이용한 방식은 왜 InvocationHandler를 서로 다른 타깃의 프록시간 공유할 수 없을까?**

- InvocationHandler가 타깃과 메소드 선정 알고리즘에 의존하고 있기 때문이다.
    
    ![Untitled (5)](https://github.com/HoChangSUNG/mentoring/assets/76422685/20582989-1d27-4098-85cf-5e8c18bedc55)

- InvocationHandler는 타깃과 메소드 선정 알고리즘이라는 상태를 가지고 있어, **stateful**하기 때문에 공유가 불가능 →  jdk 프록시를 생성하는 팩토리 빈에서도 InvocationHandler를 DI 받지 않고, 내부에서 생성해서 사용

### 어드바이스와 포인트컷, 어드바이저

- **어드바이스** : 부가기능을 제공하는 오브젝트
- **포인트컷** : 메소드 선정 알고리즘을 담은 오브젝트
- **어드바이저**
    - 어드바이저 = **어드바이스 + 포인트컷**
    - 어드바이스와 포인트컷을 묶은 오브젝트

### ProxyFactoryBean 동작 방식

![Untitled (6)](https://github.com/HoChangSUNG/mentoring/assets/76422685/58f38b31-a41b-4507-85c7-853dbf30a209)

1. 프록시가 클라이언트로부터 요청을 받아 포인트컷에게 부가 기능을 적용할 메소드인지 확인
2. 프록시는 포인트컷으부터 부가 기능을 적용할 대상 메서드인지 확인받으면, MethodInterceptor 타입의 어드바이스를 호출
3. 어드바이스가 부가기능을 적용하는 중 타깃 메소드의 호출이 필요하면 Invocation 타입의 콜백 오브젝트의 proceed() 메소드를 호출하여 타깃 오브젝트 호출

### ProxyFactoryBean, Advice, Pointcut을 적용한 구조

![Untitled (7)](https://github.com/HoChangSUNG/mentoring/assets/76422685/9e8d9f8d-23a9-41ff-8225-60bf1168d034)

### 트랜잭션 부가기능을 ProxyFactoryBean에 적용 예시

```java
public class TransactionAdvice implements MethodInterceptor{
	PlatformTransactionManager transactionManager;

	public void setTransactionManager(PlatformTransactionManager transactionManager){
		this.transactionManager = transactionManager;
	}
	
	public Object invoke(MethodInvocation invocation) throws Throwable{
		TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
		try{
			Object ret = invocation.proceed();
			transactionManager.commit(status);
			return ret;
		}catch(RuntimeException e){
			transactionManager.rollback(status);
			throw e;
		}
	}
}
```

<br>

## 6.5 스프링 AOP

### 반복적인 ProxyFactoryBean 설정 문제 해결 방법

- 문제 : 부가기능의 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정정보를 추가해주는 부분
- 해결 방법 : 자동 프록시 생성기를 이용해 타깃 오브젝트의 프록시를 자동으로 생성해줌

### 자동 프록시 생성기(자동 프록시 생성 빈 후처리기)

- 어드바이저를 이용한 자동 프록시 생성기(DefaultAdvisorAutoProxyCreator)
    - DefaultAdvisorAutoProxyCreator는 BeanPostProcessor 인터페이스를 구현한 빈 후처리기
    - 빈 후처리기 : 스프링 빈 오브젝트가 만들어지고 난 후, 빈 오브젝트를 다시 가공할 수 있게 해줌
        - 스프링은 빈 후처리기가 빈으로 등록되어 있으면 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청
- 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록
- **동작 방식**
    
    ![Untitled](https://github.com/HoChangSUNG/mentoring/assets/76422685/983e85a7-cb99-447f-a0d2-142b38c22fec)

    1. 빈 오브젝트를 만들 때마다 빈 후처리기(자동 프록시 생성기)에 빈을 보냄
    2. 빈 후처리기가 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인 
    3. 프록시 적용 대상이면 전달받은 빈에 대한 프록시를 만들고, 프록시에 어드바이저 연결
    4. 컨테이너가 전달해준 빈 오브젝트 대신 프록시 오브젝트를 컨테이너에 돌려줌
    

### 포인트컷 기능 2가지

- 프록시를 적용할 클래스인지 확인(프록시 생성 시)
- 어드바이스를 적용할 메서드인지 확인(프록시 사용 시)

### 포인트컷 표현식

- AspectJ 프레임워크의 일부 문법을 확장해서 사용하는 것 = AspectJ 포인트컷 표현식
- 간단한 방법으로 포인트컷의 클래스와 메소드를 선정하는 알고리즘을 작성할 수 있는 방법
- 포인트컷 지시자를 이용해 작성
    - **execution() 지시자 → 메소드 실행에 대한 포인트컷**
        
        ![Untitled (1)](https://github.com/HoChangSUNG/mentoring/assets/76422685/804ca975-7c04-409b-b479-71ebb630398f)

        - 예시
            - **`execution(* hello(..)) :` 메서드 이름이 hello, 메소드 파라미터는 모든 종류 허용**
            - `**execution(* hello())` : 메서드 이름이 hello, 메소드 파라미터가 없는 경우만**
            - `**execution(* hello(String))` : 메서드 이름이 hello, 메소드 파라미터 타입이 String**
            - `**execution(* springbook.learningtest.pointcut.*.*(..))` : springbook.learningtest.pointcut 패키지의 모든 클래스에 적용**
            - `**execution(* springbook.learningtest.pointcut..*.*(..))` :  springbook.learningtest.pointcut 패키지의 모든 서브 패키지의 클래스에 적용**
            - `**execution(* *..*TargetInterface*.**(..))` : `TargetInterface` 인터페이스를 구현한 메소드에만 포인트컷이 적용**

### 포인트컷 표현식 장단점

- 장점 : 짧은 문자열에 담겨 클래스나 코드를 추가할 필요 없어서 코드와 설정이 단순해짐
- 단점 : 문자열로 된 표현식이므로 런타임 시점까지 문법의 검증이나 기능 확인이 되지 않음

### AOP

- **aspect** : 핵심 기능에 부가되어 의미를 갖는 특별한 모듈
    - 어드바이저는 단순한 형태의 aspect
- **Aspect Oriented Programming(AOP)** : 애플리케이션의 핵심 기능에서 부가 기능을 분리해 aspect로 만들어 설계하고 개발하는 방법
    - Aspect를 분리함으로써 핵심기능을 설계하고 구현할 때 객체지향적인 가치를 지킬 수 있도록 도와주는 것
        - 핵심 기능 안으로 부가기능이 침투해 들어가 버리면 핵심기능 설계에 객체지향 기술의 가치를 온전히 부여하기 힘들어짐
- 종류
    - 스프링 AOP
        - 프록시를 이용해 부가 기능을 모듈을 타깃 오브젝트의 메소드에 적용해줄 수 있기 때문
        - **어드바이스 적용 대상이 오브젝트의 메소드로 제한**됨
    - AspectJ
        - 컴파일된 타깃의 클래스 파일을 수정하거나 크랠스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법 사용
        - **바이트 코드 조작과 같은 복잡한 방법을 왜 사용할까?**
            1. 스프링과 같은 DI 컨테이너의 도움을 받지 않고도 AOP를 적용할 수 있기 때문(컨테이너를 사용하지 않는 환경에서도 손쉽게 AOP 적용이 가능)
            2. 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하기 때문
                - 바이트 코드를 직접 조작해서 AOP를 적용하면 메소드뿐만 아니라 오브젝트의 생성, 필드 값의 조회와 조작, 스태틱 초기화 등의 다양한 작업에 부가 기능을 부여 가능
        - 단점
            - 바이트 코드 조작을 위해 JVM 실행 옵션을 변경하거나 별도의 바이트코드 컴파일러를 사용하거나, 특별한 클래스 로더를 사용하게 하는 등의 번거로운 작업이 필요

### AOP 용어

- 타깃 : 부가 기능을 부여할 대상
- 어드바이스 : 타깃에게 제공할 부가 기능을 담은 모듈
- 조인 포인트 : 어드바이스가 적용될 수 있는 위칠
    - 스프링 AOP는 조인포인트가 메소드 실행 단계밖에 없음
- 포인트컷 : 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈
- 프록시 : 부가 기능을 제공하는 오브젝트
    - DI를 통해 타깃 대신 클라이언트에게 주입되며 클라이언트의 메소들 호출을 대신 받아 타깃에 위임해주고 부가기능을 부여
- 어드바이저 : 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트
- 애스팩트 : AOP의 기본 모듈


<br>

## 6.6 트랜잭션 속성

### TransactionDefinition 인터페이스는 트랜잭션의 동작방식에 영향을 줄 수 있는 **4가지 속성을 정의**

1. **트랜잭션 전파**
    - 트랜잭션 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식
        1.  **PROPAGATION_REQUIRED**
            - 가장 많이 사용되는 트랜잭션 전파 속성
            - 진행 중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 트랜잭션이 있으면 이에 참여
        2.  **PROPAGATION_REQUIRES_NEW**
            - 항상 새로운 트랜잭션을 시작
            - 독립적인 트랜잭션이 보장되어야 하는 코드에 적용
        3.  **PROPAGATION_NOT_SUPPORTED**
            - 트랜잭션 없이 동작하도록 만듦, 진행 중인 트랜잭션이 있어도 무시
            - 특별한 메소드에만 트랜잭션 적용에서 제외할 경우 사용
                - 포인트컷에서 특정 메소드만 AOP 대상에서 제외하는 방식은 포인트컷이 복잡해지기 때문에 PROPAGATION_NOT_SUPPORTED를 쓰는 것이 나ㅇ,ㅁ
2. **격리 수준**
    - 기본 격리 수준은 DataSource에 설정되어 있는 디폴트 격리수준을 그대로 따름
3. **제한 시간**
    - 트랜잭션을 수행하는 제한시간 설정
    - DefaultTransactionDefinition의 기본 설정은 제한시간이 없음.
    - 제한 시간은 트랜잭션을 직접 시작할 수 있는 **PROPAGATION_REQUIRED, PROPAGATION_REQUIRES_NEW**와 함께 사용해야만 의미가 있음
4. **읽기 전용**
    - 읽기 전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있음.
        - 읽기 전용 속성을 위반했을 경우  TransientDataAccessResourceException 발생
    - 또한 데이터 엑세스 기술에 따라 성능이 향상될 수 있음

### TransactionInterceptor

- 트랜재션 어드바이스로 사용 + 트랜잭션 정의를 메소드 이름 패턴을 이용해서 다르게 지정할 수 있는 방법을 추가로 제공
- 예외 처리 방식
    - 런타임 예외 → 트랜잭션 롤백
    - 체크 예외 → 예외 상황으로 해석하지 않고 일종의 비즈니스 로직에 따른, 의미가 있는 리턴 방식의 한가지로 인식해서 트랜잭션을 커밋함
        - 위 기본 처리 방식과 다른 예외 처리가 가능하도록 해줌 → 특정 체크 예외의 경우 트랜잭션을 롤백시키고, 특정 런타임 예외에 대해서는 트랜잭션을 커밋시킬 수 있음
            
            ![Untitled (2)](https://github.com/HoChangSUNG/mentoring/assets/76422685/fe58a63d-dcc7-466a-9665-52d518b00e30)


### 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다

- 프록시 방식 AOP에서는 프록시를 통한 부가 기능의 적용은 클라이언트로부터 호출이 일어날 때만 가능하고, 타깃 오브젝트가 자기 자신의 메소드를 호출할 때는 부가 기능 적용이 일어나지 않음
- 이유
    - 프록시를 거쳐서 메서드 호출이 일어나는 것이 아니기 때문
- 해결 방법
    1. 스프링 API를 이용해 프록시 오브젝트에 대한 레퍼런스를 가져온 뒤 같은 오브젝의 메서드 호출도 프록시를 이용하도록 강제하는 방법
    2. AspectJ와 같은 타깃의 바이트코드를 직접 조작하는 방식의 AOP 기술을 적용

<br>

## 6.7 애노테이션 트랜잭션 속성과 포인트 컷

### @Transactional

- 트랜잭션 처리를 도와주는 애노테이션
- @Transactional의 타깃은 메소드와 타입 → 메소드, 클래스, 인터페이스에 사용할 수 있음
- 트랜잭션 속성을 정의하고, 동시에 포인트컷의 자동등록에도 사용
    - @Transactional이 부여된 모든 오브젝트를 자동으로 타깃 오브젝트로 인식, 이때 사용되는 포인트컷이 TransactionAttributeSourcePointcut

### @Transactional 애노테이션을 사용했을 때 어드바이저의 동작방식

- 사진(534p)
1. 트랜잭션 속성이 부여된 대상을 확인해서 어드바이스를 적용할지 여부를 판단
2. 애노테이션에 담긴 트랜잭션 속성 정보를 사용하여 부가 기능 적용
- 트랜잭션 부가기능 적용 단위는 메소드
- 위 방식을 이용하여 포인트컷과 트랜잭션 속성을 애노테이션 하나로 지정이 가능

### 대체 정책

- 스프링은 @Transactional을 적용할 때 4단계의 대체(fallback) 정책을 이용
- 속성을 확인할 때 **타깃 메소드, 타깃 클래스, 선언 메소드, 선언 타입(클래스,인터페이스)의 순서**에 따라 @Transactional이 적용됐는지 차례로 확인하고, 가장 먼저 발견되는 속성정보를 사용하게 하는 방법

## 6.8 트랜잭션 지원 테스트

**선언적 트랜잭션 :** AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고 속성을 지정할 수 있게 하는 방법

**프로그램에 의한 트랜잭션 :** TransactionTemplate이나 개별 데이터 기술의 트랜잭션 API를 사용해 직접 코드 안에서 사용하는 방법

### 테스트에서의 @Transactional

- 테스트 메서드에 트랜잭션 경계가 자동으로 설정
- 테스트 클래스 레벨에 부여할 수도 있음
- 트랜잭션을 강제 롤백시키도록 설정되어 있음

### @Rollback

- 테스트에서 트랜잭션을 커밋시켜서 테스트에서 진행한 작업을 그대로 DB에 반영하고 싶은 경우 사용
- @Rollback의 기본 값은 true이고, 롤백을 원하지 않으면 @Rollback(false)로 해야 함
- 메소드 레벨에만 적용 가능

### @TestConfiguration

- 롤백에 대한 공통 속성을 클래스 레벨에 지정 가능
- `@TransactionConfiguration(defaultRollback=false)`

### @NotTransactional

- 테스트 메서드에 부여할 경우 클래스 레벨의 @Transactional 설정을 무시하고 트랜잭션을 시작하지 않은 상태로 테스트를 진행
- 하지만 deprecated 되어 사용하지 않는 편이 좋음
- 대신 트래잭션 테스트와 비  트랜잭션 테스트를 클래스로 구분해서 만들도록 권장
- `@Transactional(propagation=Propagation.NEVER)`을 사용하면 @NotTransactional과 마찬가지로 트랜잭션이 시작되지 않음

<br>

## 정리

- DI를 이용한 트랜잭션의 분리는 데코레이터 패턴과 프록시 패턴으로 이해될 수 있다.
- 번거로운 프록시 클래스 작성은 JDK 다이나믹 프록시를 사용해 간단하게 만들 수 있다.
- 다이나믹 프록시는 스태틱 팩토리 메서드를 사용하여 빈으로 등록하기 어렵다 → 따라서 팩토리 빈으로 만들어야 한다.
    
    스프링은 자동시 생성 기술에 대한 추상화 서비스를 제공하는 프록시 팩토리 빈을 제공한다.
    
- 프록시 팩토리 빈의 설정이 반복되는 문제를 해결하기 위해 자동 프록시 생성기와 포인트컷을 활용한다.
    
    자동 프록시 생성기는 부가기능이 담긴 어드바이스를 제공하는 프록시를 스프링 컨테이너 초기화 시점에 자동으로 만들어준다.
    
- 포인트컷은 AspectJ 포인트컷 표현식을 사용해서 작성하면 편리하다.
- AOP는 OOP만으로는 모듈화하기 힘든 부가기능을 효과적으로 모듈화하도록 도와주는 기술이다
- 스프링은 자주 사용되는 AOP 설정과 트랜잭션 속성을 지정하는 데 사용할 수 있는 전용 태그를 제공한다.
- AOP를 이용해 트랜잭션 속성을 지정하는 방법에는 포인트컷 포현식과 메소드 이름 패턴을 이용하는 방법, 타깃에 직접 부여하는 @Transactional 애노테이션을 사용하는 방법이 있다.
- @Transactional 을 이용한 트랜잭션 속성을 테스트에 적용하면 손쉽게 DB를 사용하는 코드의 테스트를 만들 수 있다.
