# 2장 흐름 정리

### 웹을 통한 dao 테스트

- 모든 레이어의 기능을 다 만들고 나서 테스트가 가능하다는 문제점
- 하나의 테스트를 수행하는데 참여하는 클래스와 코드가 너무 많아 에러가 어디서 발생했는지 찾기 힘들다는 문제
<Br><Br>

### 작은 단위의 테스트

- 관심사의 분리를 테스트에 적용해서 작은 단위로 쪼개서 테스트를 진행하여 원인을 빠르게 찾아낼 수 있음
- 이런 것들을 하기 위해 **단위 테스트**를 사용
  <Br><Br>
### UserDaoTest 발전(웹을 통한 dao 테스트 문제점 해결)

- 자동 수행 테스트 코드
    - 웹을 통해 dao를 테스트하면 수작업으로 테스트를 진행해야 해서 귀찮은데, main()로 실행하면 테스트 실행 시 자동으로 테스트가 수행되고 결과가 나옴
- 지속적인 개선과 점진적인 개발을 위한 테스트
    - 코드를 수정하면서 테스트를 조금씩 수정하는 방식으로 진행하여 코드를 개선하는 작업에 속도가 붙고 더 쉬워짐(매주 작은 단계를 거치는 동안 테스트를 수행했기 때문)
    - 여기에 기능을 추가하고 그에 맞는 테스트를 추가하는 식으로 점진적인 개발을 하여 새로운 기능이 의도한대로 동작하는지 확인하고, 기존의 기능들이 새로운 기능으로 인해 영향을 받는지 확인할 수 있음
      <Br><Br>
### UserDaoTest문제점

- 수동 확인 작업의 문제점
    - 콘솔의 결과를 사람의 눈으로 일일이 확인해야 하는 문제
    - 테스트 결과를 확인하는 일은 사람의 책임이므로 완전히 자동으로 테스트되는 방법은 아님

**→ 테스트 검증의 자동화를 통해 해결**

- if-else문을 이용하여 테스트 검증을 자동화 할 수 있음
- 실행 작업의 번거로움
    - dao가 많아지면 그에 따라 main()메소드도 생성해야 하는데, 전체 기능을 테스트하기 위해 main() 메소드를 모두 실행해야 하는 문제가 존재
      <Br><Br>
### **JUnit**

- main() 메소드만을 이용해 테스트를 작성하는 것은 애플리케이션 규모가 커지고 테스트 개수가 많아지면 테스트 수행하는 일이 부담이 되는 문제를 해결
- JUnit은 프레임워크이기 때문에 main() 메소드도 필요없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요가 없음
  <Br><Br>
### 테스트 결과의 일관성

- Junit으로 변경한 `addAndGet()`은 테스트가 진행된 이후에 db에 저장된 값을 제거해주지 않았기 때문에 테스트 결과의 일관성을 보장하지 못한다는 문제가 존재한다
- 따라서 아래와 같이 `addAndGet()`은 테스트의 맨 앞에 `deleteAll()`과 `getCount()`를 추가하여 db에 저장된 기존 정보를 제거하여 일관성을 보장

    ```java
    @Test
    public void addAndGet() throws SQLException{
    	dao.deleteAll();
    	assertThat(dao.getCount,is(0));
    }
    ```

<Br><Br>
### 포괄적인 테스트

- addAndGet() 테스트 메소드는 하나의 User만 db에 저장했고 그 이상의 수는 저장하지 않아 getCount() 메소드가 정확하게 동작하는지 확인이 불가능
- 따라서 어떤 코드에 대한 모든 기능을 점검할 수 있도록 여러번의 add()를 한 후에 getCount()를 통해 결과를 확인하는 테스트 메소드가 필요
  <Br><Br>
### 예외 조건에 대한 테스트

- 예를 들어 기존 테스트 코드들은 모두 성공하는 경우만 테스트만 작성하였기 때문에 예외상황에 대한 테스트를 할 수 없다
- 따라서 예외 상황일 경우에 대한 테스트를 만들어 예외를 발생시키면 테스트가 성공하도록 테스트 코드를 작성해야 함
  <Br><Br>
### TDD
<Br><Br>
### 테스트 메소드에서의 중복 제거

- 테스트 메소드에서 반복되는 코드를 @Before을 사용하는 메소드로 추출하여 중복되는 부분을 제거(applicationContext에서 빈을 조회하는 부분)
  <Br><Br>
### 스프링 테스트 컨텍스트 프레임워크 적용

- 테스트마다 애플리케이션 컨텍스트가 새로 생성되지 않고, 테스트 메소드와 테스트 클래스간 애플리케이션 컨텍스트를 공유할 수 있도록 해줌