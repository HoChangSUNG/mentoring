# 4장 예외

### 예외 처리 worst practice

1. **예외가 발생하면 catch 블록에서 예외를 다시 발생시키지 않는 경우**
    - 예외 발생시 catch 블록을 사용해서 예외를 잡아내는 것까지는 좋지만, 그 후 catch블록에서 예외를 다시 던지지 않고 별문제 없는 것처럼 넘어가는 것은 매우 위험한 일
        - **프로그램 실행 중 오류가 있어서 예외를 발생시켰는데 그것을 무시하고 정상 흐름처럼 계속 진행해버리기 때문**
        - 만약, 아래 코드와 같이 catch에서 로그만 출력해줄 경우 → 다른 로그나 메시지에 묻혀 놓치기 쉬움
            
            ```java
            }catch(SQLException e){
            	e.printStackTrace();	
            }
            ```
            
        - 결국 발생했던 예외로 인해 어떤 기능이 비정상적으로 동작하거나, 메모리나 리소스가 소진되거나 예상치 못한 다른 문제를 일으킬 수 있다.
        - 최종적으로는 **시스템 오류나 이상한 결과의 원인이 무엇인지를 찾아내기가 매우 힘듦**
    - 따라서 **굳이 예외를 잡아서 조치를 취할 방법이 없다면 예외를 catch로 잡지 말고 발생하도록 냅둬야 한다**
    
2. **무의미하고 무책임한 throws 선언**
    - 메소드 선언에 throws 선언을(`throws Exception`) 기계적으로 붙이는 경우 심각한 문제점이 존재
        - 메소드 선언에서 의미 있는 정보를 얻을 수 없어 **실행 중에 예외적인 상황이 발생 가능하다**는 것인지, **습관적으로 throws를 복사해서 붙여 놓은 것**인지 알 수 없고, 결과적으로 **적절한 처리를 통해 복구될 수 있는 예외 상황도 제대로 다룰 수 있는 기회를 박탈 당함**
    

- **예외 처리 시 반드시 지켜야 할 핵심 원칙**
    - **모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보되어야 한다**

<br><br>

### 예외의 종류와 특징

- **Error**
    - 시스템에 비정상적인 상황이 발생했을 때 사용 → 주로 자바 VM에서 예외를 발생시키고, catch 블록으로 잡아봤자 대응할 수 있는 방법이 없으므로(`OutOfMemoryError, ThreadDeath`) 애플리케이션 코드에서 catch 하려고 하면 안됨
- **CheckedException**
    - Exception 클래스의 서브 클래스이면서 RuntimeException을 상속하지 않은 것
    - **예외 발생 메소드에서 예외를 반드시 처리해야 하는 책임이 존재**
        
        → 예상하지 못했던 예외 상황에서 발생하기 때문
        
        따라서 예외 발생 시 반드시 catch문으로 잡든지 throws를 이용해 메소드 밖으로 던져야 함
        
    - 예외를 복구할 수 있는 가능성이 있는 경우에 사용
        
        → 예외 상황이 발생할 수 있음을 인식하도록 도와주고 이에 대한 적절한 처리를 시도해보도록 요구
        
    
- **UnCheckedException**
    - Exception 클래스의 서브 클래스이면서 RuntimeException을 상속한 것
    - **예외 발생 메소드에서 예외를 반드시 처리해야 하는 책임이 존재하지 않음**(명시적인 예외 처리를 강제하지 않음)
        
        → 예상하지 못했던 예외 상황에서 발생하는 것이 아닌 피할 수 있지만 **개발자가 부주의해서 발생할 수 있는 경우에 발생하도록 하는 것**이기 때문
        
        따라서 예외 발생 시 반드시 catch문으로 잡거나 throws 선언을 할 필요가 없음
        

![Untitled (3)](https://github.com/HoChangSUNG/mentoring/assets/76422685/2a541bf7-708e-4ca0-ae06-08c080709294)

<br><br>

### 예외 처리 방법

1. **예외 복구**
    - 예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것
    - **예외로 인해 기본 작업 흐름이 불가능하면 다른 작업 흐름으로 자연스럽게 유도하여 예외 상황이 다시 정상**으로 돌아오면 이를 **예외를 복구**했다고 볼 수 있음
    - 예시
        - 네트워크 접속이 원활하지 않아 예외 발생 시 일정 시간 대기했다가 재시도하여 예외 상황으로부터 복구를 시도
        - 파일을 읽으려 시도하는데, 해당 파일이 없거나 다른 문제로 인해 읽히지 않아 예외 발생 시, 사용자에게 다른 파일을 이용하도록 하여 예외 상황으로부터 복구를 시도
2. **예외 처리 회피**
    - 예외를 자신이 처리하지 않고 자신을 호출한 쪽으로 던져 예외 처리를 회피하는 방법
    - throws 문으로 선언해 예외 발생시 알아서 던져지게 하거나 catch 문으로 예외를 잡고 다시 예외를 던지는 방식
    - **예외를 회피하는 것**은 긴밀한 관계에 있는 다른 오브젝트에게 예외처리 책임을 분명히 지게 하거나, 자신을 사용하는 쪽에서 예외를 다루어야 하는 것처럼 **의도가 분명해야 함**
        - 무책임한 책임 회피가 되어버릴 수 있기 때문 → 모듈에서 발생한 구체적인 예외를 외부의 메소드가 제대로 처리할 수 있을지 생각해봐야 함
3. **예외 전환**
    - 예외를 복구해 정상적인 상태로 만들 수 없어 발생한 예외를 전환해서 메소드 밖으로 던지는 방법
    - 목적
        - 내부에서 발생한 예외 상황에 대한 적절한 의미를 분명하게 해줄 수 있는 예외로 변경하기 위해서
            
            예시 : 사용자 등록 시 이미 아이디가 같은 사용자가 존재하는 경우 SQLException 예외가 발생하지만 이를 의미가 분명한 예외인 DuplicateUserIdException으로 바꾸어 던져 다른 계층에서 적절한 복구 작업을 시도할 수 있음
            
        - 체크 예외를 언체크 예외(런타임 예외)로 바꾸어 예외를 쉽고 단순하게 처리할 수 있도록 포장(wrap)하기 위해서
            - 예시 :EJB 컴포넌트 코드에서 발생하는 대부분의 체크 예외는 비즈니스 로직에서 의미 있거나 복구 가능한 예외가 아니기 때문에 런타임 예외로 전환하여 다른 계층에서 예외를 잡아 다시 던지거나 불필요한 throws 선언을 줄여줄 수 있다.

**중첩 예외**

- 새로운 예외를 만들고 원인(cause)이 되는 예외를 내부에 담은 예외
- 
- `getCause()`를 이용해 처음 이전에 발생한 예외가 무엇인지 확인 가능
- 중첩 예외는 아래 코드처럼 새로운 예외를 만들고 생성자나 initCause() 메소드로 근본 원인이 되는 예외를 넣어주면 됨
    
    ```java
    catch(SQLException e){
    	...
    	throw new DuplicateUserIdException(e);
    }
    
    catch(SQLException e){
    	Exception ex = new DuplicateUserIdException();
    	ex..initCause(e);
    	throw ex;
    }
    ```
<br><br>

### 예외 처리 전략

**런타임 예외의 보편화**

- 체크 예외는 복구할 가능성이 있는 상황에서 예외를 처리할 때 사용하고,  언체크 예외는 시스템 장애나 프로그램 오류에 사용한다.
- 자바의 환경이 서버로 이동하면서 지금은 항상 복구할 수 있는 예외가 아니라면 **언체크 예외로 만드는 것이 보편화**되고 있다
    - 이유
        - 자바 엔터프라이즈 서버 환경에서는 수많은 사용자가 동시에 요청을 보내 각 요청이 독립적인 작업으로 취급되고, 특정 계층에서 예외가 발생했을 때 작업을 일시 중지하고 사용자와 커뮤니케이션 하면서 예외 상황을 복구할 수 있는 방법이 없어 체크 예외의 활용도와 가치가 떨어졌기 때문이다
        - 대응이 불가능한 체크 예외를 계속 throws 선언을 통해 던져야 하는 의미 없는 행동만 계속 해야 하므로 차라리 언체크 예외로 전환해 던져 그 밖의 메소드들은 해당 예외를 신경 안쓰게 해주는 편이 나음
- 예시
    - SQLException(체크 예외)은 대부분 복구가 불가능한 예외이므로 예외를 잡아봤자 처리할 것도 없고, 결국 throws를 통해 앞으로 전달되다 애플리케이션 밖으로 던져질 것이기 때문에 차라리 런타임 예외로 포장해 던져 버리고 그 밖의 메소드들은 신경쓰지 않도록 하는 방법
    - 코드
        
        ```java
        public void add() throws DuplicatedUserIdException{
        	try{
        		// jdbc 사용해 user 정보를 db에 저장하는 코드
        	}catch(SQLException e){
        		if(e.getErrorCode() == MysqlErrorNumber.ER_DUP_ENTRY) throw new DuplicatedUserIdException(e);
        		else throw new RuntimeException(e);
        	}
        }
        ```
        
    
    **어플리케이션 예외**
    
    - 시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고, 반드시 catch해서 조치를 취하도록 요구하는 예외
    - 처리 방법
        - 예외 상황 발생 시 정상적인 리턴 값과 구분되는 예외 상황에 맞는 리턴 값 전달
            - 문제
                - 예외 상황에 대한 리턴 값을 명확하게 코드화하고 잘 관리하지 않으면 혼란 생길 수 있음
                - 결과 값(리턴 값)을 확인하는 조건문이 자주 등장해서 if 블록 범벅이 된 코드가 될 수 있음
        - 정상적인 흐름을 따르는 코드는 그대로 두고, 예외 상황에서는 비즈니스적인 의미를 띈 예외를 던짐

<br><br>

### 스프링의 JdbcTemplate의 예외 처리 전략

- 사용하는 예외 처리 전략 : **런타임 예외로 전환하는 예외 처리 전략(SQLException → DataAccessException으로 포장해서 던져줌)**
    - SQLException은 복구가 거의 불가능하고, DAO 밖에서 SQLException을 다룰 수 있는 가능성이 거의 없음
    - 또한 필요도 없는 throws 선언으로 범벅이 될 수 있기 때문에 런타임 예외로 전환하는 예외 처리 전략을 사용했다.
- DataAccessException 목적
    - 런타임 예외로 SQLException을 포장해주는 역할
    - SQLException에 담긴 다루기 힘든 상세한 예외 정보를 의미 있고 일관성 있는 예외로 전환해서 추상화해주려는 용도

<br><br>

### JDBC의 한계

- JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 JDBC API 형태로 정해두고, DBㄴ업체가 JDBC 표준을 따라 만들어진 드라이버를 제공하여 DB의 종류에 상관없이 일관된 방법으로 프로그램을 개발할 수 있다
- 하지만, DB를 자유롭게 변경해서 사용할 수 있는 유연한 코드를 작성하게 해주지는 못한다.(DB 종류에 상관없이 사용할 수 있는 데이터 엑세스 코드를 작성하지는 못함)
- DB를 자유롭게 변경해서 사용할 수 있는 유연한 코드를 작성하지 못하는 이유
    1. 비표준 SQL 
        - db에 종속적인 비표준 SQL은 DB의 특별한 기능을 사용하거나 최적화된 SQL을 만드는데 유용하여 많이 사용되고,
            
            **DAO는 특정 DB에 대해 종속적인 코드(비표준 SQL)를 사용하게 되어, 다른 DB로 변경하려면 비표준 SQL을 수정**해야 하기 때문이다.
            
    2. 호환성 없는 SQLException의 db 에러 정보
        - 호환성 없는 에러 코드와 표준을 잘 따르지 않는 상태 코드를 가진 SQLException만으로는 db에 독립적인 유연한 코드를 작성하는 것은 불가능
        - 에러 코드 → SQLException에서 getSQLState() 메소드로 예외 상황에 대한 상태 정보 조회 가능, but DB에 따라 에러 코드가 달라짐
        - 상태 코드 → DB에 독립적인 에러 정보를 얻기 위한 코드, but DB의 JDBC 드라이버에서 SQLException을 담을 상태 코드를 정확하게 만들어주지 않는 문제

**호환성 없는 SQLException의 db 에러 정보 문제 해결 방법**

- DB 종류에 상관없이 동일한 상황에서 일관된 예외를 전달 받아 해결 가능하고 스프링은 이 문제를 **DataAccessException**을 통해 해결
- DB 종류에 상관없이 동일한 상황에서 일관된 예외를 전달 받을 수 있는 이유
    - 스프링은 DB별 에러 코드를 분류하고 스프링이 정의한 예외 클래스와 매핑하여 DB가 달라져도 같은 종류의 에러라면 동일한 예외를 받을 수 있음


<br><br>

### DAO 인터페이스와 구현의 분리

- **dao를 따로 만들어서 사용하는 이유**
    1. 데이터 엑세스 로직을 담은 코드를 성격이 다른 코드에서 분리해놓기 위해서
    2. 분리된 dao는 전략 패턴을 적용해 구현체를 변경해서 사용할 수 있게 만들기 위해서

- **dao를 인터페이스로 분리해도 dao 인터페이스를 기술에 완전히 독립적으로 만들지 못하는 이유**
    1. 인터페이스로 메소드의 구현은 추상화 했지만 구현 기술마다 던지는 예외가 다르기 때문에 메소드의 선언이 달라진다는 문제가 존재하기 때문
        
        ```java
        public void add(User user) throws PersistenceException; //JPA
        public void add(User user) throws HibernateException; //Hibernate
        public void add(User user) throws JdoException; //JDO
        ```
        
    2. 데이터 엑세스 기술이 달라지면 같은 예외 상황에서도 서로 다른 종류의 예외가 던져진다.
        - 중복 키 에러 발생시
            
            → JDBC : SQLException 발생
            
            → JPA  : JdoException 발생
            
            → HIBERNATE : HibernateException 발생
            
  <br><br>

### DataAccessException
    
- **스프링에서 DB에 독립적으로 적용 가능한(특정 기술에 종속되지 않는) 추상화된 런타임 예외 계층을 제공, 자바의 주요 데이터 엑세스 기술에서 발생할 수 있는 예외를 추상화**
- **DB 사용 기술에 독립적인 일관성 있는 예외 제공**
- **데이터 엑세스 기술에서 발생 가능한 대부분의 예외를 계층 구조**로 분리해놓음
  - InvalidDataAccessResourceUsageException : **기술의 종료에 상관 없이** 데이터 엑세스 기술을 부정확하게 사용할 때 발생, 거의 대부분 프로그램을 잘못 작성해서 발생하는 오류
    - BadSqlGrammerException : JDBC에서 발생
    - HibernateQueryException : 하이버네이트에서 발생
    - …….
  - OptimisticLockingFailureException : 낙관적인 locking 예외
    - ObjectOptimisticLockingFailureException, JdbcOptimisticLockingFailureException, ……
                
      ![Untitled (4)](https://github.com/HoChangSUNG/mentoring/assets/76422685/f1e96f8a-639d-410a-a981-9a5ea4a6fd99)

            
- 활용시 주의 사항
  - DataAccessException이 기술에 상관없이 어느 정도 추상화된 공통 예외를 변환해주지만 근본적인 한계때문엥 완벽하지는 않음
  - 예시 :  DuplicateKeyException는 JDBC에서만 발생하고, JPA나 다른 데이터 엑세스 기술에서는 다른 예외가 발생하게 된다
    - 이유 : JDBC는 SQLException에 담긴 에러 코드를 바로 해석하지만 jpa나 hibernate 등에서는 각 기술이 재정의한 예외를 가져와 스프링이 최종적으로 DataAccessException으로 변환하여 db의 에러 코드와 달리 이런 예외들이 세분화되어 있지 않기 때문
            
             
            
    
    ### 정리
    
    - 스프링은 DataAccessException을 통해 db에 독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공하고, db에 독립적인 일관성 있는 예외를 제공한다
    - DAO를 데이터 엑세스 기술로부터 독립시키기 위해서는 인터페이스 도입, 런타임 예외 전환, 기술에 독립적인 추상화된 예외로 전환이 필요하다
