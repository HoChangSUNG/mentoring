# 2장 테스트

스프링이 개발자에게 제공하는 가장 중요한 가치

- 객체 지향 → 애플리케이션이 변하고 그 변화에 대응하여 확장과 변화를 고려한 객체지향적 설계, 그것을 효과적으로 담아낼 수 있는 IOC/DI 기술
- 테스트 → 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있게 해줌
<Br>

**테스트**

- 내가 예상하고 의도한 대로 코드가 정확히 동작하는지 확인해서, 만든 코드를 확신할 수 있게 해주는 작업
- 테스트 결과가 원하는 대로 나오지 않으면 코드나 설계에 결함이 있음을 확인 가능

  → 디버깅(코드의 결함을 제거해가는 작업)을 통해 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신 얻음

<Br>

**웹을 통한 DAO 테스트 방법의 문제점**

- 서비스 클래스, 컨트롤러 등 모든 레이어의 기능을 다 만들고 나서 테스트해야 함
- 하나의 테스트를 수행하는데 참여하는 클래스와 코드가 너무 많기 때문에 문제가 발생할 경우 어디에서 문제가 발생했는지 찾아내야 함

<Br>

**단위 테스트**

- 작은 단위의 코드에 대해 테스트를 수행하는 것
- 코드의 변경사항이 없다면 **항상 일관성 있는 결과가 보장**되어야 함, 외부 환경에 영향(db등)을 받지 않아야 하고, 테스트의 실행 순서를 바꿔도 동일한 결과가 보장되어야 함
- 단위 : 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위
- 단위 테스트 하는 이유
    - 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지 개발자 스스로 빨리 확인받기 위해

<Br>

**포괄적인 테스트**

- 만들어진 코드의 기능을 모두 점검할 수 있는 테스트
- 항상 네거티브 테스트를 먼저 만들자 - 로드 존슨
    - 예외 테스트를 먼저 만들고 성공하는 테스트를 만들자

<Br>


**TDD(Test Driven Development)**

- 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법
- 기본 원칙 → 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다.
- 장점
    - 코드를 만들어 테스트를 실행하는 사이의 간격이 매우 짧아 오류를 빨리 발견할 수 있음
    - 자연스럽게 단위 테스트를 만들 수 있음
- 왜 개발자는 테스트를 잘 만들지 않는 것일까?
    - 앤터프라이즈 애플리케이션의 테스트를 만들기가 매우 어렵다고 생각하기 때문

  → 스프링은 테스트하기 편리한 구조의 애플리케이션을 만들게 도와주고, 엔터프라이즈 애플리케이션 테스트를 빠르고 쉽게 작성할 수 있도록 제공

    - 코드를 만들고 나서 시간이 많이 지나면 테스트를 만들기 귀찮아서


<Br>

**Main() 메소드를 이용한 UserDaoTest 문제점**

- 수동 확인 작업의 번거로움
    - 콘솔의 결과를 사람이 확인하여 성공적으로 테스트 되는지 확인해야 함
- 실행 작업의 번거로움
    - DAO가 많아지고 그에 대한 main() 메소드도 그만큼 만들어져 전체 기능을 테스트하기 위해 main() 메소드를 수백 번 실행하는 수고가 발생

→ 테스트를 자동으로 검증해주고 실행해주는 테스트용 프레임워크(JUnit) 사용이 필요해짐

<Br>


**JUnit**

- 테스트 수행 방식
    1. 테스트 클래스에서 @Test가 붙은 public이고 void형이고 파라미터가 없는 테스트 메소드를 찾는다
    2. 각 테스트 메소드를 실행하기 위해 각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다
    3. @Test가 붙은 테스트 메소드 실행 이전 혹은 이후에 @Before,@After 가 붙은 메소드를 실행한다.
- 왜 테스트 메소드를 실행할 때마다 새로운 오브젝트를 생성하는 것일까?
    - 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실하게 보장해주기 위해서 매번 새로운 오브젝트를 생성한다.
- 픽스처(Fixture)
    - 테스트를 수행하는 데 필요한 정보나 오브젝트
    - 보통 여러 테스트에서 반복적으로 사용하여 @Before 메소드를 이용해 생성해두면 편리

<Br>


**스프링 테스트 컨텍스트 프레임워크**

- 테스트가 실행되기 전 딱 한번만 애플리케이션 컨텍스트를 생성하고, 테스트 메소드와 테스트 클래스의 컨텍스트 공유
    - 테스트 메소드의 컨텍스트 공유 : 동일한 오브젝트 내의 테스트 메소드에 컨텍스트를 공유
    - 테스트 클래스의 컨텍스트 공유 : 동일한 애플리케이션 컨텍스트 설정 파일을 사용하는 클래스 사이에서 애플리케이션 컨텍스트를 공유
- 왜 스프링 테스트할 때 테스트 컨텍스트를 사용해서 애플리케이션 컨텍스트를 공유해야 할까?
    - Application context를 테스트 메서드마다 생성하면 다음과 같은 문제가 발생하기 때문
        1. 빈이 많아지고 복잡해지면 애플리케이션 컨택스트 생성에 적지 않은 시간이 들 수 있기 때문
- SpringJUnit4ClassRunner라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 @RunWith 에 지정 + @ContextConfiguration을 통해 애플리케이션 컨텍스트 설정 파일 위치 지정
    - @RunWith : JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용
    - @ContextConfiguration : 자동으로 만들어줄 애플리케이션 컨텍스트 설정파일 위치 지정
- @Autowired
    - @Autowired가 붙은 인스턴스 변수가 테스트 클래스 내에 있을 때
        1. 인스턴스 변수와 타입이 일치하는 빈이 애플리케이션 컨텍스트에 있으면 해당 빈을 인스턴스 변수에 주입
        2. 인스턴스 변수와 타입이 일치하는 빈이 애플리케이션 컨텍스트에  여러개 있으면 같은 변수와 같은 이름의 빈이 있는지 확인하고 변수에 주입
        3. 변수 이름으로도 빈을 찾을 수 없으면 예외 발생

<Br>


**인터페이스를 두고 DI를 적용해야 하는 이유**

1. 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문
    - 인터페이스를 사용해 DI를 주입받아 수정에 들어가는 시간과 비용의 부담을 줄여줄 수 있기 때문
2. 효율적인 테스트를 만들기 위해서
    - 효율적인 테스트를 만들기 위해서는 작은 단위의 대상에 국한해서 테스트해야 하는데, DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는데 중요한 역할을 해서
3. 다른 차원의 서비스 기능을 도입할 수 있기 때문
    - **부가 기능을 추가할 수 있고 DI를 적용하여 AOP기술 또한 사용할 수 있다.**

<Br>

**@DirtiesContext**

- 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려줌
- 이 어노테이션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유 허용 X → 새로운 애플리케이션 컨텍스트 생성해서 다음 테스트가 사용하도록 해줌
- @DirtiesContext이 붙은 메소드의 실행이 끝나면 이후에 진행되는 테스트에서는 변경된 애플리케이션 컨텍스트는 폐기되고 새로운 애플리케이션 컨텍스트가 만들어짐

<Br>


**침투적 기술과 비침투적 기술**

- 침투적 기술
    - 기술을 적용했을 때 애플리케이션 코드에 기술 관련 API가 등장하거나, 기술 관련 인터페이스나 클래스를 사용하도록 강제하는 기술
    - **애플리케이션 코드가 해당 기술에 종속되어 버림**
- 비침투적 기술
    - 기술을 적용했을 때 애플리케이션 코드에 아무런 영향을 주지 않는 기술
    - **애플리케이션 코드가 기술에 종속적이지 않고, 순수한 코드를 유지할 수 있게 해줌**

<Br>


### 학습 테스트

- 사용할 API나 프레임워크 기능을 테스트로 보면서 사용 방법을 익히는 목적
- 테스트이지만 프레임워크나 기능에 대한 검증이 목적이 아니라, 테스트를 작성하려고 하는 기술이나 기능에 대해 이해하고 있는지, 사용 방법을 제대로 알고 있는지 검증하는게 목적

<Br>

### 버그 테스트

- 코드에 오류가 있을 때 그 오류를 가장 잘 드러내 줄 수 있는 테스트
- 장점
    - 테스트의 완성도를 높여줌
    - 버그의 내용을 분석하게 해줌
    - 기술적인 문제를 해결하는데 도움이 됨

<Br>


### 동등 분할과 경계값 분석

- 동등 분할 : 같은 결과를 내는 값의 범위를 구분해서 각 대표 값으로 테스트 하는 방법
- 경계값 분석 : 에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트하는 방법