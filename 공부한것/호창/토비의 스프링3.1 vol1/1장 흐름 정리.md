# 1장 흐름 정리

### **메소드 추출**  
WHY : 메소드가 증가할 때 DB 생성방법이 모든 메서드에 존재하고 수정해야 하는 경우 모든 메서드를 변경해주어야 하는 문제 해결 위해서  
HOW TO SOLVE : db 생성 방법과 관련된 부분을 메소드로 추출하여 해당 메소드만 변경하게 함  
<br>

### **템플릿 메소드 패턴 사용(DB 생성 방법과 사용 부분을 부모, 자식 클래스로 관심사 분리)**  
WHY : 다른 DB 생성 방법으로 변경해야 할 때마다 기존 dao의 코드에서 db 생성 방법을 수정해야 하는 문제 해결 위해  
HOW TO SOLVE : db 생성 방법을 자식 클래스에서 결정하도록 위임하여 새로운 db 생성 방법을 사용할 때 부모 클래스의 코드를 변경하지 않고 자식 클래스의 메서드만 재정의하여 해결  
<br>

### **DB 생성 방법을 별도의 클래스로 분리**  
WHY : dao마다 db 생성 방법을 결정하는 서브 클래스를 매번 생성해야 하는 문제를 해결 위해  
HOW TO SOLVE : 별도의 클래스로 분리하여 다른 dao에서도 이 객체를 사용하여 db 생성 방법을 사용할 수 있음  
<br>

### **DB 생성 방법을 인터페이스를 두고 구현체를 구현하는 방식으로 변경**  
WHY : 별도의 클래스로 분리한 DB 생성 방법의 메서드가 각 DB 생성 방법마다 다를 때 DB 생성 방법을 변경하면 해당 클래스를 사용하는 메서드들을 수정해야 한다는 문제 발생  
HOW TO SOLVE : DB 생성 방법을 인터페이스로 만들어 서로 다른 DB 생성 방법이라도 동일한 인터페이스를 구현했기 때문에 메서드 이름을 변경하지 못하게 제한  
<br>

### **외부(클라이언트)에게서 객체를 전달받아 의존관계를 설정하는 방식**  
WHY : 인터페이스와 인터페이스 구현체를 해당 객체가 의존하고 있어, 다른 인터페이스 구현체(다른 DB 생성 방법)를 사용해야 할 때마다 기존 코드를 수정해주어야 하는 문제 발생  
즉, DB 커넥션 기능의 확장이 자유롭지 못함  
HOW TO SOLVE : 객체의 생성, 연관관계 설정 관심사와 객체를 사용하는 관심사를 분리하기 위해 클래스는 인터페이스에만 의존하고 외부에서 런타임에 객체 연관관계를 설정할 수 있도록 해줌  
이 과정을 통해 오브젝트간 영향을 주지 않고 필요에 따라 자유롭게 확장 가능한 구조로 변경  
<br>

### **오브젝트 팩토리를 이용해 객체 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 분리**  
WHY : 현재 클라이언트는 객체 생성,연관관계 설정과 객체를 사용하는 관심사가 분리되어 있지 않아 클라이언트의 역할이 많다는 문제 발생  
HOW TO SOLVE: 오브젝트 팩토리는 객체 생성, 연관관계 설정 관심사를 수행하고, 클라이언트는 생성된 객체를 사용하는 관심사로 분리  
<br>

### **IOC 컨테이너(애플리케이션 컨텍스트)를 사용하여 범용적으로 IOC 기능을 확장**  
WHY : 애플리케이션이 커질수록 오브젝트 팩토리를 추가해야 하고, 이런 경우 클라이언트가 필요한 오브젝트를 가져오기 위해서 어떤 팩토리 클래스를 사용해야 하는지 확인하고, 필요할 때마다 팩토리 클래스를 사용해야 하는 문제점 발생  
HOW TO SOLVE : 애플리케이션 컨텍스트를 사용하여 애플리케이션이 커져 여러 설정파일을 추가해야 해도, 일관된 방식으로 원하는 오브젝트를 얻을 수 있음  
