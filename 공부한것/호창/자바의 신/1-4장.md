# 1장 - 4장

**메소드**

- 어떤 값을 주고 결과를 넘겨주는 것
    - ①public static ②void ③main(④String[] args)  ⑤throws Exception{
      ⑥System.out.println(”test”);
      }
        - ①제어자(modifier)
            - 메서드의 특성을 정하는 부분
        - ②리턴 타입(return type)
            - 메서드가 끝났을 때 돌려주는 타입
        - ③ 메서드 이름(method name)
        - ④매개 변수 목록(parameter list)
            - 매개변수의 목록을 말함
        - ⑤예외 목록(exception list)
            - 예외 목록을 선언
        - ⑥메스드 내용(method body)
            - 중괄호 안의 내용
- **메서드 선언시 반드시 있어야 하는것**
    - 리턴 타입, 메서드 이름, 메서드 내용


**클래스**

- 현실세계를 프로그램으로 표현할 수 있게 해주고 자바의 가장 작은 단위
- 상태(state)와 행동(behavior)이 있어야 함.
    - 상태 : 클래스의 특성을 결정짓는 것(변수)
    - 행동 : 메서드

인덴트 : 코드 앞의 공백(tab)

**예약어(reserved word)**

- 이미 자바에서 등록되어 사용되고 있다.
- 예약되어 있어 클래스, 메서드, 변수 이름으로 사용하지 못한다.

**자바 컴파일 및 실행 절차**

![KakaoTalk_20230613_144634770.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3eb79e1e-58cb-4593-a0ca-db5bf50ce1e7/KakaoTalk_20230613_144634770.jpg)

- 컴파일러 : 컴파일을 하는 프로그램
    - 컴파일 : 내가 작성한 코드를 컴퓨터가 이해할 수 있도록 엮어주는 작업, class 파일이 생성되어 디스크에 저장
- 실행( java 클래스 파일, JVM)
    - `java HelloGodOfJava` 처럼 .class 확장자 지정 안해줌 → 클래스 파일 중 동일한 이름을 가진 클래스 찾아서 실행
- JVM → 운영체제
    - JIT 컴파일러를 사용하여 바이트 코드를 기계어로 변경(19장에서 자세히 나옴)

> CarManager, Car 클래스가 존재하고 CarManager가 Car를 참조하고 있을 경우, CarManager 클래스를 컴파일하면, Car 클래스도 컴파일됨
즉, **클래스 컴파일시 참조하는(의존하는) 클래스도 같이 컴파일**한다.
>

**main 메소드가 반드시 존재해야 하는가?**

- 실행을 목적으로 하는 모든 자바 클래스에는 main 메소드가 반드시 존재해야 함
- 이유 : java 명령으로 시작하는 자바 프로그램의 시작점이 main()메소드이기 때문에, 수많은 클래스 중 적어도 하나의 main()가 존재해야 함.

**주석**

- 어떤 줄이 실행되지 않도록 하기 위해 사용
- 종류
    - 한줄 주석
        - 한줄만 주석 처리
        - `//`
    - 블록 주석
        - 여러 줄을 한꺼번에 주석 처리
        - `/**/`
    - 문서용 주석 :
        - `/**
          */`
        - 위 주석이 클래스 선언 바로 앞, 메서드 선언 바로 앞에 있으면 문서용 주석으로 인식

**객체(인스턴스)**

- 각각의 실제 사물을 나타내기 위한 것

**메모리 관점에서의 객체 생성 과정**

1. 필요한 클래스를 클래스 로더를 통해 로딩한다.
    - 클래스를 로딩하는 과정에서 static initialization을 통해 해당 클래스의 정적 변수 및 정적 블록(static block)을 초기화한다.
2. 객체 생성을 위해 heap 영역에 메모리를 할당한다.
3. 생성자를 호출하여 객체를 초기화한다.
4. 객체가 생성되고 초기화된 후 객체의 참조(reference)를 반환

**클래스 생성자**

- 객체 생성을 위한 도구
- 기본 생성자(default constructor)
    - 매개 변수가 없는 생성자
    - 개발자가 정의한 생성자가 없을 경우 컴파일시 컴파일러가 클래스 파일 안에 자동으로 생성

**객체와 클래스 차이**

- 클래스는 껍데기(틀)에 불과, 클래스 자체만으로는 일을 할 수 없음
- 객체는 new예약어를 통해 클래스 생성자를 호출하여 생성, 객체를 생성하면 일을 할 수 있음.

**객체지향 4가지 특징**

- 추상화
    - 객체의 공통적인 속성과 기능을 추출하여 정의하는 것
    - 추상 클래스와 인터페이스를 이용해 구현 가능
    - 역할(인터페이스)과 구현(구현체)을 분리 가능
        - 인터페이스를 통해 역할 부분이 추상화
- 상속
    - 부모 클래스의 기능을 자식 클래스가 그대로 물려받는 것
    - 재사용성, 부모 클래스의 기능을 쉽게 사용 가능
- 다형성
    - **같은 이름의 메서드가** **상황에 따라 다른 역할을 수행하는 것**
    - 인터페이스와 구현 객체로 분리하여 객체 설계
    - 오버라이딩, 오버로딩 이용
    - 장점
        - **클라이언트**는 인터페이스가 **어떻게 구현되었는지 구현체를 몰라도** 된다
        - **클라이언트**는 구현체 **내부 구조가 변경**되어도 영향을 받지 않음
        - 인터페이스를 구현한 객체 인스턴스를 실행 시점에 클라이언트 코드의 변경 없이 유연하게 변경가능
- 캡슐화
    - **서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것**
    - 접근 제어자를 이용해  필요한 부분만 외부로 노출
    - 장점
        - 정보 은닉 : 데이터의 직접적인 접근을 막고, 공개된 인터페이스를 통해서만 객체 접근만 가능

# 4장

**변수 종류와 생명주기**

- 지역변수(local variables)
    - 중괄호 내에서 선언된 변수
    - 생명주기 : 지역변수 선언한 중괄호 내에서만 유효
- 매개변수(parameters)
    - 메소드에 넘겨주는 변수
    - 생명주기 : 메서드가 호출될 때 시작, 메소드가 끝나면 소멸
- 인스턴스 변수(instance variable)
    - 메소드 밖, 클래스 안에 선언된 변수, static이라는 예약어가 안붙어있음
    - 생명주기 : 객체가 생성될 때 시작, 그 객체를 참조하고 있는 다른 객체가 없으면 소멸
      (GC 메모리에서 자동 할당 해제)
    - 기본 자료형이 인스턴스 변수로 선언되어 있으면,  기본 자료형이 생성된 객체의 내부에 저장됨, 즉 heap 영역에 생긴 객체 내부에 저장됨
- 클래스 변수(class variable)
    - 메소드 밖, 클래스 안에 선언된 변수, static이라는 예약어가 붙어있는 변수
    - 생명주기 : 클래스가 처음 호출될 때 시작, 자바 프로그램이 끝날 때 소멸

- 왜 변수를 위치에 따라 다르게 부르는가?
    - 각 변수의 생명주기, 용도가 다르기 때문

**변수 이름 기본 규칙**

- 길이 제한 x
- 첫 문자 → 유니코드 문자, 알파벳, $, 만 올 수 있음
  하지만 보통 $,_으로 변수 시작 안함
- 두번째 문자부터 → 유니코드 문자, 알파벳, $, 숫자 다 됨
- **상수**일 경우 → 모두 대문자, 단어 사이를 `_` 로 구분

**초기화**

- 변수를 선언하고 처음으로 값을 저장하는 것
- 초기화 하는 이유?
    - 변수를 선언할 때, 초기화를 해줘야 변수를 사용할 수 있는 상황이 되기 때문
    - 클래스 영역에서 변수 선언시 컴파일러가 자동으로 초기값을 할당해주나

      메소드 영역에서 선언할 경우 자동으로 초기값이 할당되지 않아 `The local variable a may not have been initialized` 발생


## 자바의 타입(자료형)

- **기본 자료형(primitive data type)** 과 **참조 자료형(reference data type)**으로 구분
- 기본자료형 : 자바에서 여러 형태의 타입 미리 정의되어 있음
- 참조 자료형 : 마음대로 만들 수 있음

  ※ String은 참조 자료형이지만 new를 사용하지 않고 객체를 생성하지 않아도 되는 유일한 타입

- 기본 자료형과 참조 자료형 차이
    - 초기화할 때 **new를 사용**하여 초기화하는 것이 참조 자료형, **new를 사용하지 않고** 바로 초기화 가능한것이 기본 자료형
    - 실제 값을 가지는 것이 아닌 데이터가 저장된 메모리 주소값을 가지는 것이 참조 자료형, 실제 값을 가지는 것이 기본 자료형


### 기본 자료형

- 정수형 : byte, short, int ,long, char(**unsigned**)
- 소수형 : float(4bytes), double(8bytes)
- 기타 : boolean

- 정수형
    - 정수형 범위
        - byte    1byte  -2^7 ~ 2^7-1

          short   2byte  -2^15 ~ 2^15-1

          int       4byte  -2^31 ~ 2^31-1

          long    8byte  -2^63 ~ 2^63-1

          char    2byte   0 ~ 2^16-1 (**unsigned**)

        - MSB는 음수, 양수 표현을 위해 사용
        - 바이트의 최소 크기는 왜 -128일까?
            - 하나의 값이라도 더 제공하기 위해서
            - 10000000 이 **0이 아니라 -128로 표현**하기 때문
    - char 값 지정하는 방법
        - 홑따옴표 안에 값을 직접 넣는 것 → `char value = 'a'`
        - 홑따옴표 안에 \u16진수 값 넣는 것 → `char value = '\u1128'`
        - 유니코드 번호 지정(char 범위 내의 숫자) → `char value = 999`

    - byte형은 왜 만들어졌나?
        - 데이터를 저장할 때 byte값 이용해 저장
        - 적은 공간에 보다 많은 내용을 저장하기 위해서
            - 만약 int로 저장할 경우에는 저장공간이 byte에 비해 많이 필요해서

    - long 타입 선언시 L 붙여주어야 하는 이유
        - 자바에서는 정수숫자를 명시하면 int로 간주하기 때문에, long 타입의 숫자를 명시적으로 지정하면 숫자 뒤에 L을 붙여야 함. ( `long longMax=123L;` )
        - L을 붙이지 않았을 때 그 숫자가 int 범위 내에 있으면 문제가 없지만, int 범위를 넘어가게 되면 컴파일 에러가 발생하므로,  L을 붙이는 것이 좋음
            - `long longMax=9223372036854775807;` → 컴파일 에러(int로 간주하는데, int 범위 넘음)
            - `long longMax=9223372036854775807L;` → 정상(long으로 간주, long 범위 이내)

    - char가 정수형인 이유
        - char가 정수형이라면 형 변환이 가능해야 한다. 아래와 같이 int로의 형 변환이 잘 이루어지기 때문에 char는 정수형이다
        - `int a= 'a'; // 97` → int 범위가 더 넓어서 형변환 굳이 명시적으로 안해도 됨

- 실수형
    - 소수점 처리를 위해 사용
    - float → 4bytes, 대량으로 소수점 자리수가 적은 데이터 저장하려고 할 경우 자주 사용
    - double → 8bytes로 표현, 일반적으로 사용
    - float 타입 선언시 F 붙여주어야 하는 이유
        - 자바에서 실수형 숫자를 명시하면 double로 간주하기 때문에, float 타입의 숫자를 명시적으로 지정하면 숫자 뒤에 F 붙여야 함

    - **돈 계산과 같은 정확한 계산이 요구될때 float, double 사용하면 안되는 이유**
        - float, double이 제공할 수 있는 범위를 넘어서면 값의 정확성을 보장하지 못하기 때문
          (오차)
        - 따라서 **BigDecimal** 클래스를 사용해야 함(java.math)
    - IEEE 754
        - float ,double  계산시 IEE754 부동 소수점 방식을 사용하여 계산
        - float → 부호(1자리)+지수(8자리)+가수(23자리) = 32비트
        - double → 부호(1자리) + 지수(11자리) + 가수(52자리) = 64비트

    - 부동 소수점 vs 고정 소수점
        - 고정 소수점은 정수 표현하는 비트수와 소수를 표현하는 비트 수를 고정되어 있어 값의 범위와 정밀도가 제한되어 있는 반면

          부동 소수점 방식은 고정 소수점 방식보다 값의 범위와 정밀도가 더 높아 큰 수를 표현할 수 있다.

- 기본 자료형의 기본 값
    - 지역변수로 기본 자료형 사용할 경우
        - 변수를 초기화하지 않고 변수를 사용하면 컴파일 에러 발생
        - but, 지역변수 선언만 하고, 사용하지 않으면 컴파일 에러가 발생하지는 않음
    - 인스턴스, 클래스 변수로 사용할 경우
        - 변수를 초기화하지 않고 변수를 사용하면 → 정수형은 0, 실수형은 0.0, bolean은 false, char는 공백 문자(\u0000) 로 설정되어 있음


**java.math.BigInteger**

- long 타입 범위를 넘어서는 정수를 표현하기 위한 클래스
- Number 추상 클래스 상속 및 Comparable 인터페이스 구현
- 불변 객체이며 정수 크기에 제한이 없음
- 내부에 int 배열이 존재하고 그 안에 정수들을 표현

**java.math.BigDecimal**

- float, double은 소수점의 정밀도가 정확하지 않아 오차가 발생할 수 있는 문제를 해결해주기 위한 클래스
- Number 추상 클래스 상속 및 Comparable 인터페이스 구현
- BigDecimal 클래스의 변수로 intVal(BigInteger), precision(int), scale(int)이 존재
    - precision : 숫자를 구성하는 전체 자리수, 왼쪽이 0이 아닌 수가 시작하는 위치부터 오른쪽이 0이 아닌 수로 끝나는 위치까지의 총 자리수
    - scale : 전체 소수점 자리수, 소수점 첫째 자리부터 오른쪽부터 0이 아닌 수로 끝나는 위치까지의 총 소수점 자리수
- BigInteger에 값을 저장하고, precision과 scale을 이용해 소수 부분을 구분한다.
    - ex) 012.45 → BigInteger에 1254 라는 값을 저장하고 precision는 4, scale은 2인 상태로 BigDecimal 내부에 저장되어 있음


**리터럴이란?**

- 프로그램에서 직접 표현한 값
- 종류
    - 정수 리터럴(Integer Literals) : 정수 값을 나타내는 리터럴, int a = 10에서 10이 리터럴
    - 부동 소수점 리터럴(Floating-Point Literals) : 실수 값을 나타내는 리터럴, double pi = 3.14에서 3.14가 리터럴
    - 문자 리터럴(Character Literals) : 문자 값을 나타내는 리터럴, char ch = ‘A’ 에서 A가 리터럴
    - 문자열 리터럴(String Literals) : 문자열 값을 나타내는 리터럴, String a=”ab”에서 ab가 리터럴
    - 논리 리터럴(Boolean Literals) : 논리 값을 나타내는 리터럴, boolean flag = true에서 true가 리터럴
- 왜 사용하는가?
    - 코드에서 값을 간단하고 명확하게 나타내기 위해
- 사용되는 곳
    - 변수 및 상수 초기화
        - int a=12;
    - 연산 및 표현식
        - result = 3+5;
    - 매소드 매개변수로 전달
        - System.out.println(”Hello, World”);