# chapter7 파일 시스템

리눅스는 저장 장치에 접근할 때 파일 시스템을 이용하여 접근하고, 저장 장치에 직접 접근하지 않는다

### **파일 시스템**

- 사용자에게 의미 있는 하나의 데이터를 이름, 위치, 사이즈 등의 보조 정보를 추가하여 파일이라는 단위로 관리해주는 시스템, **저장 장치 상에 존재**
- 파일 시스템 덕분에 각 데이터(파일)의 이름을 기억해 놓으면 저장 장치에서 데이터의 위치나 사이즈 등의 복잡한 정보를 기억할 필요가 없다.
- 사용자(프로세스)가 파일 읽기 시스템 콜을 사용해 파일 이름,파일 상의 오프셋, 사이즈를 지정하면 파일 시스템을 다루는 처리가 해당 데이터를 저장장치에서 찾아 사용자에게 전달
    
    ![KakaoTalk_20230821_145338515](https://github.com/HoChangSUNG/mentoring/assets/76422685/3337d0d0-d68b-4b78-937a-a91e8bea5112)

- 파일 시스템은 ext4, XFS, Btrfs 등 다양한 파일 시스템이 존재하고 파일 시스템에 따라 저장 장치의 데이터 구조, 그것을 처리하기 위한 프로그램(ext4용 처리 프로그램, XFS용 처리 프로그램 등)이 다름,
    
    리눅스는 **여러 개의 파일 시스템**을 다룰 수 있음
    
- **사용자가 파일 시스템을 사용하는 시스템 콜 호출 시 파일의 데이터 읽는 순서(파일 시스템에 관계없이 통일된 인터페이스로 접근)**
    1. 커널 내의 모든 파일시스템 공통 처리가 동작하고 대상 파일의 파일시스템을 판별
    2. 각 파일시스템을 처리하는 프로세스를 호출하여 시스템 콜에 대응되는 처리를 함
    3. 데이터의 읽기를 하는 경우 디바이스 드라이버에 처리를 의뢰
    4. 디바이스 드라이버가 데이터를 읽어 들임  
        ![KakaoTalk_20230821_145338515_01](https://github.com/HoChangSUNG/mentoring/assets/76422685/8f72a13f-0fb5-4e82-b565-c6e2f3bfd8c1)


- **파일 시스템은 왜 필요할까???**
    - 파일 시스템이 없다면, 저장 장치에 어떤 파일이 어디에 있는지, 어느 정도의 크기를 가지는지, 어디가 저장장치의 빈 영역인지를 알지 못하고, 이 부분들을 개발자가 직접 기록하고 관리해야 하기 때문
    - 이렇듯 파일 시스템이 사용자에게 의미 있는 하나의 데이터를 이름, 위치, 사이즈 등의 보조 정보를 추가하여 파일이라는 단위로 관리하게 해주는 역할을 하기 때문에 필요하다.
- 리눅스의 파일 시스템에는 파일을 보관하는 특수한 파일인 디렉터리가 존재하고, 디렉터리 안에 일반적인 파일, 또는 다른 디렉터리를 보관하는 것이 가능
    - 이러한 방식을 위해 리눅스의 파일 시스템은 **트리 구조**로 되어 있음
        
        ![KakaoTalk_20230821_145338515_02](https://github.com/HoChangSUNG/mentoring/assets/76422685/938af104-fbb0-405e-a2de-b6f207412f73)

- **파일시스템의 데이터 종류**
    - 데이터 : 사용자가 작성한 문서나 사진, 동영상, 프로그램 등의 내용
    - 메타 데이터 : 파일의 이름이나 저장 장치 내에 위치 사이즈, 종류, 시간 정보, 권한 정보와 같은 보조 정보
        - 종류 : 일반 파일인지 디렉토리인지 혹은 다른 종류의 파일인지 판별하는 정보
        - 시간 정보 : 작성 시간, 최근 접근 시간, 최근 변경 시간
        - 권한 정보 : 어느 사용자가 파일에 접근 가능한지
    
    ※ df 명령어를 통해 얻은 파일 시스템의 스토리즈 사용량 → 파일 시스템에서 작성한 모든 파일의 합계 사이즈 + 메타데이터 사이즈
    
- **쿼터**
    - 파일 시스템의 용량을 용도 별로 사용할 수 있게 제한하는 기능
    - 왜 사용할까?
        - 시스템을 여러 용도로 사용하는 경우 특정 용도가 파일시스템의 용량을 무제한으로 사용하면, 다른 용도로 사용할 용량이 부족해지게 되는 일이 발생하기 때문이다
        - 특히 root 권한으로 동작하는 프로세스가 이용하는 시스템 관리 처리를 위한 용량이 부족하게 되면 시스템 전체가 정상적으로 동작하지 못한다.
    - 종류
        - 사용자 쿼터
            - 파일의 소유자인 사용자별로 용량을 제한, ext4와 XFS가 사용 가능
            - 예시 → 특정 사용자로 인해 /home이 가득 차게 되는 사태 방지
        - 디렉터리 쿼터(혹은 프로젝트 쿼터)
            - 특정 디렉터리 별로 용량을 제한하는 것, ext4와 XFS가 사용 가능
            - 예시 → 다른 팀원과 공유하는 디렉터리에 용량 제한을 걸어둠
        - 서브 볼륨 쿼터
            - 파일시스템 내의 서브 볼륨이라는 단위별 용량을 제한하는 것, Btrfs가 사용 가능
- **파일 시스템이 깨지는 것을 막기 위한 방법**
    - 저널링 → ext4, XFS는 저널링을 사용해 파일 시스템 깨지는 것 방지
    - Copy on Write → Btrfs는 Copy on Write를 사용해 파일 시스템 깨지는 것 방지

**저널링**

- 저널 영역을 이용해 파일 시스템이 깨지는 것을 방지
- 순서
    1. 업데이트에 필요한 아토믹한 처리의 목록을 저널 영역에 작성
        - 저널 로그 : 저널 영역에 작성된 아토믹한 처리 목록
    2. 저널 영역의 내용을 바탕으로 실제로 파일 시스템의 내용을 업데이트
        
        ![KakaoTalk_20230821_145338515_03](https://github.com/HoChangSUNG/mentoring/assets/76422685/46862f88-c350-4dfb-a1b2-5b1109bf58e1)

- 파일 시스템이 깨졌을 때
    - 업데이트 도중 파일 시스템이 깨지면, 저널 로그를 처음부터 다시 수행해 파일 시스템이 깨지지 않도록 방지

**Copy on Write**

- 파일의 내용을 업데이트 할 때마다 파일 내용을 업데이트 하면, 업데이트한 파일의 내용을 다른 장소에 작성하고 업데이트하기 전의 파일을 링크하지 않고, 업데이트한 파일을 링크하여 링크를 고쳐 쓰는 방식으로 동작
    
    ![KakaoTalk_20230821_145338515_04](https://github.com/HoChangSUNG/mentoring/assets/76422685/b5985f7e-71de-4ee6-bbd8-5298b61dc6d0)

- 파일 시스템이 깨졌을 때
    - 업데이트된 파일을 다른 장소에 작성한 후에 전원이 꺼져도, 재부팅 후에 업데이트 된 파일을 삭제하여 업데이트 전의 링크를 유지하게 함
    

### **파일 시스템의 깨짐을 막을 수 없는 경우**

- 저널링이나 Copy on write를 사용해도 파일 시스템이 깨질 경우 파일 시스템에 준비된 복구용 명령어(**fsck**)를 이용하여 백업한 시점으로 복원
- fsck 명령어는 어느 파일 시스템에도 공통적으로 존재하는 명령어
- fsck를 추천하지 않는 이유
    - 파일 시스템이 깨졌는지 확인하거나 복구하기 위해 파일 시스템 전체를 조사해야 하기 때문에 복구 소요 시간이 파일 시스템 사용량에 따라 증가
    - 복구에 오랜 시간을 들여도 실패하는 경우가 많기 때문
    - 사용자가 원하는 상태로 복원한다고 보장 불가 → 복원하면서 깨진 데이터는 내용과 관계없이 삭제됨

### 파일 종류

- **일반 파일(사용자 데이터 저장), 디렉터리(파일을 보관), 디바이스 파일**
- 디바이스 파일
    - 하드웨어 상의 장치를 파일로서 표현한 것, /dev에 존재
        
        ```bash
        $ ls -l /dev/
        total 0
        crw-rw-rw- 1 root tty 5, 0 Dec 18 11:39 tty
        ...
        brw-rw---- 1 root disk 8, 0 Dec 17 09:49 sda
        ```
        
        - 최초의 문자가 c → 캐릭터 장치, 최초의 문자가 b → 블록 장치
    - 디바이스 파일 종류
        - **캐릭터 장치**
        - **블록 장치**

**캐릭터 장치**

- 디바이스 파일의 한 종류, 읽기와 쓰기가 가능하지만 탐색이 되지 않는 특징이 있음
- 예시
    - 터미널 : 여기서는 bash 등의 shell을 통해 명령어를 실행하기 위해 문자열만으로 이루어진 흑백 화면 혹은 윈도우라고 생각
        - 터미널의 디바이스 파일은 다음 시스템 콜을 이용
            - write() 시스템 콜 : 터미널에 데이터 출력
            - read() 시스템 콜 :  터미널에 데이터 입력
        - **bash의 조작을 통해 최종적으로 디바이스 파일의 조작으로 변환!**
    - 키보드
    - 마우스

**블록 장치**

- 단순히 파일의 일고 쓰기 이외에 랜덤 접근 가능
- 블록 장치는 일반적으로 직접 접근하지 않고, 파일 시스템을 경유해 사용
- 블록 장치를 직접 다루는 경우
    1. 파티션 테이블의 업데이트(parted 명령어 등 사용)
    2. 블록 장치 레벨의 데이터 백업 & 복구(dd 명령어 등 사용)
    3. 파일 시스템의 작성(각 파일시스템의 mkfs 명령어 사용)
    4. 파일 시스템의 마운트(mount 명렁어 사용)
    5. fsck
- 예시
    - HHD, SSD

**파일 시스템 종류**

- **ext4** : Unix가 만들어질때부터 있는 파일의 작성, 삭제, 읽고 쓰기 등의 단순한 기능만을 제공
- **XFS** : Unix가 만들어질때부터 있는 파일의 작성, 삭제, 읽고 쓰기 등의 단순한 기능만을 제공
- **메모리를 기반으로 한 파일 시스템**
    - 메모리에 작성하는 파일 시스템(tmpfs)
    - 이 파일 시스템에 보존한 데이터는 전원 꺼버리면 사라지지만 저장 장치의 접근이 전혀 발생하지 않기 때문에 고속으로 사용 가능
        
        ![KakaoTalk_20230821_145338515_05](https://github.com/HoChangSUNG/mentoring/assets/76422685/158dbeae-9ec4-4407-aa44-714c7b161caf)

    
- **네트워크 파일시스템**
    - 네트워크를 통해 연결된 원격 호스트에 있는 파일을 접근하는 파일 시스템
        - windows 호스트상의 파일에 접근할 때 cifs 파일 시스템 사용
        - UNIX, OS를 사용하는 호스트 상의 파일에 접근할 때 nfs 파일 시스템 사용
        
        ![KakaoTalk_20230821_145338515_06](https://github.com/HoChangSUNG/mentoring/assets/76422685/0892501c-1a41-4b9e-b79f-8e54b1d9102a)


- **가상 파일시스템**
    - 커널 안에 여러 가지 정롭를 얻기 위해 또는 커널의 동작을 변경하기 위한 파일 시스템
    - procfs : 시스템에 존재하는 프로세스에 대한 정보 얻기 위해 사용하는 파일 시스템
    - sysfs : procfs를 마구잡이로 사용하는 것을 막기 위해 이러한 정보를 배치하는 장소를 어느 정도 정하기 위해 만든 것
    - cgroupfs
        - 하나의 프로세스 혹은 여러 개의 프로세스로 만들어진 그룹에 대해 여러 가지 리소스 사용량의 제한을 cgroup을 cgroupfs 파일 시스템을 통해 사용
        - cgroup을 다룰 수 있는 것은 root만 가능
    
- **Btrfs**
    - Unix가 만들어질때부터 있는 파일의 작성, 삭제, 읽고 쓰기 등의 단순한 기능만이 아니라 풍부한 기능을 제공
    - 여러개의 저장 장치/파티션으로부터 거대한 스토리지 풀 생성하고 거기에 마운트 가능한 서브 볼륨을 작성
    - **스냅샷**
        - 서브 볼륨 단위로 만들 수 있음
        - 스냅샷 작성 시 데이터를 전부 복사하는 것이 아니고, 데이터를 참조하는 메타 데이터의 작성하여 일반적인 복사보다 빠르게 이루어지고, 서브 볼륨과 스냅샷이 데이터를 공유하여 공간적인 낭비도 적음
