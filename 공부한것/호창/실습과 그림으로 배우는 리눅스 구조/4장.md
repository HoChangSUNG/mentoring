# chapter4 프로세스 스케쥴러

### 프로세스 스케쥴러

- 하나의 cpu는 동시에 하나의 프로세스만 처리할 수 있음
- 하나의 cpu에 여러 개의 프로세스를 실행해야 할 때는 각 프로세스를 타임 슬라이스를(적절한 시간으로 쪼개서) 번갈아 가며 처리
    - 각 프로세스는 대략 같은 타임 슬라이스를 가짐

**컨텍스트 스위칭**

- 논리 cpu 상에서 동작하는 프로세스가 바뀌는 것
- 프로세스가 어떤 프로그램을 수행 중이더라도 타임 슬라이스를 모두 소비하면 발생
    - **프로세스가 예상 시간보다 처리 시간이 오래 걸릴 경우 가능성 2가지**
        1. 프로세스 처리 중에 컨텍스트 스위칭이 발생해서 다른 프로세스가 실행되었을 가능성
        2. 프로세스 처리 중 문제가 발생했을 가능성
    

**프로세스 상태**

- ps ax 명령어 → 시스템에 존재하는 프로세스를 한 줄씩 목록으로 확인
    - 갹 프로세스의 상태는 ps ax 실행시 출력 결과의 STAT 필드의 첫 문자로 알 수 있음
        - R → 실행 상태 혹은 실행 대기 상태
        - S,D → 슬립 상태
            - 시그널에 따라 실행 상태로 되돌아 오는 것 → S
            - 시그널이 와도 실행 상태로 되돌아가지 않은 것 → D
        - Z → 좀비 상태
- **상태**
    - **실행 상태** : 현재 논리 cpu를 사용하고 있음
    - **실행 대기 상태** : cpu 시간이 할당되기를 기다리고 있음
    - **슬립 상태** : 이벤트가 발생하기를 기다리고 있으며, 이벤트 발생하기 전까지는 cpu 시간을 사용하지 않음
    - **좀비 상태** : 프로세스가 종료한 뒤 브모 프로세스가 종료 상태를 인식할 때까지 기다림
    
- 슬립 상태에서 기다리는 이벤트 예시
    - 정해진 시간이 경과하는 것
    - 사용자 입력 기다림(마우스,키보드)
    - HDD, SSD 같은 저장 장치의 읽고 쓰기 종료를 기다림
    - 네트워크의 데이터 송수신 종료를 기다림
- 장시간 D 상태로 있는 경우 원인
    - 스토리지의 I/0가 종료되지 않은 상태로 되어 있는 경우
    - 커널 내에 뭔가 문제가 발생하는 경우

### **IDLE 상태**

- 논리 CPU가 동작하지 않는 상태
- 사실 cpu가  idle 상태일 때는 **idle 프로세스**가 동작하고 있음
    - idle 프로세스
        - 아무것도 하지 않는 특수한 프로세스
        - cpu의 특수한 명령을 이용해 논리 cpu를 휴식 상태로 만들고, **하나 이상의 프로세스가 실행 가능한 상태가 될 때까지 소비 전력을 낮춰 대기 상태**로 만듦
- 노트북이나 스마트폰으로 아무것도 하지 않은 상태일 때 배터리가 오래가는 이유는?
    - 아무것도 하지 않는 경우 idle 상태이고, idle 상태일 때에는 idle 프로세스가 실행되어 소비 전력을 낮추기 때문
- sar 명령어를 사용해 단위 시간당 논리 CPU가 얼마나 IDLE 상태가 되는지 확인 가능 
  
    ![KakaoTalk_20230803_194922283](https://github.com/HoChangSUNG/mentoring/assets/76422685/10c484db-904d-4a92-a7f4-d35a35b702bb)    

### 스루풋과 레이턴시

- 스루풋
    - 단위 시간당 처리된 일의 양
    - 완료한 프로세스 수/ 경과 시간
- 레이턴시
    - 각각의 처리가 시작부터 종료까지의 경과된 시간
    - 처리 종료 시간 - 처리 시작 시간
- 실험(각각의 process는 0.1초간 동작한다고 가정)
    - 논리 cpu 1개, process 1개
        - 스루풋 : 1 프로세스/0.1초 → 10 프로세스/1초
        - 평균 레이턴시 : 0.1초  → 100ms
    - 논리 cpu 1개, process 2개
        - 스루풋 : 2 프로세스/0.2초 → 10 프로세스/1초
        - 평균 레이턴시 : 0.2초 → 200ms
    - 논리 cpu 1개, process 4개
        - 스루풋 : 4프로세스/0.4초 → 10 프로세스/1초
        - 평균 레이턴시 : 0.4초 → 400ms
        
- **스루풋과 레이턴시 정리**
    - **idle 상태가 적어질수록 스루풋은 좋아지나, 모든 논리 cpu가 idle 상태가 되지 않은 경우에는 프로세스 개수를 늘려도 스루풋은 동일**
        - 정확하게는 모든 논리 cpu가 idle 상태가 되지 않은 경우에 프로세스 개수를 늘리면 **컨텍스트 스위치의 오버헤드 등**으로 **스루풋 감소**
    - 프로세스 수를 늘릴수록 레이턴시 악화
    - 각 프로세스의 평균 레이턴시는 비슷
    - **스루풋가 레이턴시가 최대가 되는 경우**
        - 논리 cpu가 idle 상태가  없고, 실행 대기 상태의 프로세스가 없는 경우

- **실제 시스템에서 스루풋과 레이턴시**
    - cpu 상태
        - idle 상태 : 논리 cpu가 쉬고 있어 스루풋이 떨어지는 경향
        - 프로세스 동작 중 : 프로세스가 동작 중이므로 이상적인 상태이지만. 다른 프로세스가 실행 대기 중이라면 프로세스들의 레이턴시가 길어짐
        - 프로세스 대기 중 : 실행 대기 프로세스가 존재, **스루풋은 높지만 레이턴시가 길어지는 경향**
    - **스루풋과 레이턴시는 trade-off 관계**
        - 스루풋이 높아지면(프로세스 수 증가) 레이턴시는 나빠짐
        - 스루풋이 낮아지면(프로세스 수 감소) 레이턴시는 좋아짐
    - sar의 %idle → idle 상태 비율
    - sar -q의 runq-sz 필드 → 실행 중, 실행 대기 프로세스의 수를 표시

### 글로벌 스케쥴러(로드 밸런서)

- 여러 개의 논리 CPU에 프로세스를 공평하게 분배해주는 역할
- **멀티 코어 환경에서 스루풋과 레이턴시**
    - 멀티 코어 환경에서 여러 개의 프로세스를 동시에 동작시키지 않으면 스루풋은 오르지 않음
    - 한개의 논리 CPU인 경우와 마찬가지로, 프로세스 수를 논리 CPU 수보다 많게 하더라도 스루풋은 오르지 않음

### **경과 시간과 사용 시간**

- time 명령어를 통해 경과 시간과 사용 시간을 알 수 있음
- **경과 시간**
    - 프로세스가 시작해서 종료할 때까지 경과 시간
    - time 명령어의 결과에서 `‘real’` 값
- **사용 시간**
    - **프로세스들**이 실제로 논리 cpu를 사용한 시간
    - `‘user’` 값 + `‘sys’` 값
        - `‘user’`→ 프로세스가 실행 중인 사용자 모드에서 CPU를 사용한 시간
        - `‘sys’`→ 프로세스의 실행 중 시스템 콜을 실행한 시간
- 실험( 프로세스가 10초 동안 동작한다고 가정)
    - 예시 사진
    - 논리 cpu 1개, 프로세스 1개
        - 경과 시간 : 10초, 사용 시간 : 10초
        
        → 1개의 프로세스가 논리 cpu 독점해서 경과시간과 사용시간이 거의 일치
        
    - 논리 cpu 1개, 프로세스 2개
        - 경과 시간 : 20초, 사용 시간 : 20초
    - 논리 cpu 1개, 프로세스 4개
        - 경과 시간 : 40초, 사용 시간 : 40초
    - 논리 cpu 2개, 프로세스 1개
        - 경과 시간 : 10초, 사용 시간 : 10초
    - 논리 cpu 2개, 프로세스 2개
        - 경과 시간 : 10초, 사용 시간 : 20초
            
            → 사용시간이 경과시간의 2배 → **사용 시간이 cpu가 동작한 시간을 합친 것이기 때문**
            
    - 논리 cpu 2개, 프로세스 4개
        - 경과 시간 : 20초, 사용 시간 : 40초
            
            → 사용시간이 경과시간의 2배 → **사용 시간이 cpu가 동작한 시간을 합친 것이기 때문**
            
    
    ### 프로세스의 경과 시간과 사용 시간
    
    - ps -eo 명령어의 etime, time 필드를 통해 **프로세스의 경과 시간(ELAPSED)과 사용 시간(TIME)**을 얻을 수 있음
        - **프로세스의 경과 시간 :** 프로세스의 시작부터 현재까지 경과 시간, etime 필드
        - **프로세스의 사용 시간 :** 프로세스가 cpu를 사용한 시간 , time 필드
        - 사진
    - **프로세스의 경과 시간이 하루가 넘지만, 프로세스의 사용 시간이 10분이 될 수 있는데 어떤 경우가 가능할까?**
        - 웹 브라우저나 텍스트 에디터 같이 사용자와 인터렉티브 방식으로 동작하는 프로세스의 경우
            - 사용자 입력을 기다리는 동안 슬립 상태를 유지하여 경과 시간이 길지만, 사용 시간이 짧을 수 있음
    - 실험
        - 여기서의 **경과 시간과 사용 시간은 하나의 프로세스에 대한 것**이고, **모든 프로세스의 합이 아니라, 하나의 프로세스에 대한 경과 시간, 사용 시간**이다
        - 논리 cpu 1개, 프로세스 1개
            
            ```java
            $ taskset -c 0 python src/loop.py &       
            [1] 12165
            $ ps -eo pid,comm,etime,time | grep python
              12165 python                00:09 00:00:08
            ```
            
            - 경과 시간 : 대략 10초, 사용 시간 : 대략 10초
            - 경과 시간과 사용 시간이 비슷
        - 논리 cpu 1개, 프로세스 2개
            
            ```java
            $ taskset -c 0 python src/loop.py &
            [1] 11839
            $ taskset -c 0 python src/loop.py & # 위의 명령어 실행 직후에 바로 실행해야 정확함
            [2] 11890
            $ ps -eo pid,comm,etime,time | grep python
                11839 python                00:19 00:00:10
                11890 python                00:19 00:00:09
            		-> **각각의 프로세스에 대한 경과 시간, 사용 시간임**
            ```
            
            - 경과 시간 : 대략 20초 ,사용 시간 : 대략 10초
            - 경과 시간이 사용 시간의 거의 2배
        - 논리 cpu 1개, 프로세스 4개
            - 경과 시간 : 대략 40초 ,사용 시간 : 대략 10초
            - 경과 시간이 사용 시간의 거의 4배
        - 논리 cpu 2개, 프로세스 2개
            
            ```java
            $ taskset -c 0,4 python src/loop.py &
            [1] 12989
            $ taskset -c 0,4 python src/loop.py &
            [2] 13040
            $ ps -eo pid,comm,etime,time | grep python
              12989 python                00:09 00:00:09
              13040 python                00:09 00:00:08
            ```
            
            - 경과 시간 : 대략 10초 ,사용 시간 : 대략 10초
            - 경과 시간과 사용 시간이 비슷
    
    ### 프로세스 우선 순위 변경
    
    - nice() 시스템 콜 :  특정 프로세스의 우선순위를 부여 하는 것 가능
        - 우선 순위가 높은 프로세스는 cpu 시간을 많이 배정받고, 우선순위가 낮은 프로세스는 cpu 시간을 적게 배정
        - 기본 우선 순위 : 0
        - 우선순위는 -19 ~ 20
            - 우선순위 낮추는 것 → 리눅스 사용자 계정 누구나 가능
            - 우선순위 높이는 것 → root 권한 가지고 있는 슈퍼 유저만 가능
            - -19 → 우선순위가 가장 높음
            - 20 → 우선순위가 가장 낮음
            
        - **nice -n  명령어**를 사용하여 특정 프로그램의 우선순위를 바꾼 상태로 실행 가능
            - `nice -n 5 echo hello → echo hello`명령어를 우선순위 5로 변경 후 실행하는 예시
    
    ### sar 명령어에서 **%user와 %nice의 차이**
    
    - %nice
        - 우선 순위를 디폴드 값(0)에서 변경한 프로그램을 실행한 시간의 할당량
    - %sar
        - 우선순위가 디폴드 값(0)인 프로그램을 실행한 시간의 할당량
