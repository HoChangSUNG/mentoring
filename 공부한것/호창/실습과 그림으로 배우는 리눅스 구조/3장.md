# chapter3 프로세스 관리

### 리눅스에서 프로세스 생성의 목적

1. **같은 프로그램의 처리를 여러 개의 프로세스가 나눠서 처리**
    - 웹 서버처럼 request가 여러 개 들어왔을 때 동시에 처리해야 하는 경우
2. **전혀 다른 프로그램을 생성**
    - bash로부터 각종 프로그램을 새로 생성하는 경우

## fork() 함수

- **같은 프로그램의 처리를 여러 개의 프로세스가 나눠서 처리하기 위해 사용(**동일한 프로세스를 생성)
- fork() 함수 실행 시 실행한 프로세스(부모 프로세스)와 함께 새로운 프로세스(자식 프로세스)가 생성
    - 생성 전의 프로세스 → 부모 프로세스
    - 새롭게 생성된 프로세스 → 자식 프로세스

- **fork() 함수를 이용한 프로세스 생성 순서**
    1. 자식 프로세스용 메모리 영역을 작성하고, 거기에 부모 프로세스의 메모리 복사
    2. fork()함수의 리턴값이 다른 것을 이용해 부모, 자식 프로세스가 서로 다른 코드를 실행하도록 분기
        - fork()함수의 리턴 값
            - 부모 프로세스 : 자식 프로세스의 PID
            - 자식 프로세스 : 0

## execve() 함수

- **전혀 다른 프로그램을 생성할 때 사용**
- execve() 실행 시 프로세스 수가 **증가하는 것이 아니라 기존의 프로세스를 다른 프로세스로 변경**
- **execve() 함수를 이용한 프로세스 생성 순서**
    1. 실행 파일을 읽은 다음 프로세스의 메모리 맵에 필요한 정보를 읽어들임
    2. (코드 영역,데이터 영역의 오프셋, 사이즈, 메모리 맵 시작 주소 등)
    3. 현재 프로세스의 메모리를 새로운 프로세스의 데이터로 덮어씀
    4. 새로운 프로세스의 첫 번째 명령부터 실행(엔트리 포인트)
    

### **※전혀 다른 프로세스 새로 생성시 보통 fork and exec 방식 사용**

- **fork and exec**
    - 부모가 될 프로세스로부터 fork() 함수를 호출하여 자식 프로세스를 생성하고, 자식 프로세스에서 execve()를 호출하는 방식
        ![KakaoTalk_20230801_174358342](https://github.com/HoChangSUNG/mentoring/assets/76422685/43f8bac3-a1e3-4ba5-80d8-48292bdcb674)        

**실행 파일 구조**

- 코드 영역 : 프로세스 실행 중에 사용하는 코드들이 저장
- 데이터  영역 : 프로세스 실행 중에 사용하는 데이터가 저장
- 보조 영역
    - 코드와 데이터 영역의 파일상 오프셋, 사이즈, 메모리 맵 시작 주소
    - 엔트리 포인트(entry point) : 최초로 실행할 명령의 메모리 주소
        ![KakaoTalk_20230801_174358342_01](https://github.com/HoChangSUNG/mentoring/assets/76422685/e4559ae8-a1fb-47ef-b556-721a71224ba3)        

**코드 영역과 데이터 영역의 메모리 맵 시작 주소가 필요한 이유는?**

- cpu에서 실행되는 명령은 특정 메모리 주소를 지정하여 명령에 사용할 데이터를 읽거나 저장할 수 있기 때문

**프로세스 종료 처리**

- 프로그램 종료는 **_exit() 함수** 사용(내부적으로 exit_group() 시스템 콜 호출)
- **_exit() 함수는 프로세스에 할당된 메모리 전부 회수**
- 직접 _exit()호출하는 대신 대부분 C 라이브러리의 exit() 함수를 호출하여 프로세스 종료함
