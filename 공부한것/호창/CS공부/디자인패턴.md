
### 싱글톤 패턴

인스턴스를 하나만 만들어 사용하기 위한 패턴이다. 장점이자 단점은 전역 상태를 만들 수 있기 때문에 아무 객체나 해당 인스턴스에 접근 할 수 있다는 점이다.

또한 싱글톤 패턴은 객체를 테스트 더블로 대체하기 어렵고, 동적으로 객체를 주입하기도 어렵다.

<br>
<br>

### 전략 패턴

- **전략 패턴**이란 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리시키고 이를 구현한 구체적인 알고리즘  클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 패턴이다.
    
    위에서 말하는 **알고리즘**은 독립적인 책임으로 분리가 가능한 기능을 말한다.
    
- **의도**는 알고리즘을 사용하는 클라이언트와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 하려는 의도이다.

<br>
<br>


### 빌더 패턴

빌더 인스턴스를 만들고 빌더에서 객체를 대신 만들도록 하는 방식이다. 또한 선택적으로 필요한 데이터만 설정할 수 있고, 매개변수가 많을 때 가독성을 높일 수 있다.

또한 테스트 코드를 작성할 때 필요한 매개변수만 쉽게 보여줄 수 있어 가독성을 높일 수 있다.

<br>
<br>


### 팩토리 메소드 패턴

- **팩토리 메소드 패턴**이란 **팩토리 메소드 방식**을 통해 오브젝트 생성 방법을 슈퍼클래스의 기본 코드에서 독립시키는 방법이다.
    
    **의도**는 슈퍼 클래스에서 객체를 생성하기 위한 인터페이스를 제공하지만 하위 클래스가 생성될 객체의 유형을 변경할 수 있도록 하기 위해서이다.
    
    **팩토리 메서드**는 서브 클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것이다
    

<br>
<br>


### 템플릿 매소드 패턴

**템플릿 매소드 패턴**이란 변하지 않는 기능을 슈퍼클래스에, 자주 변경되며 확장할 기능을 서브 클래스로 구현하도록 하는 패턴이다.

또한 **템플릿 메소드 패턴의 의도**는 알고리즘의 전체적인 구조를 정의하고, 서브 클래스에서 알고리즘의 특정 단계를 재정의할 수 있도록 하기 위함이다.

<br>
<br>


### 어댑터 패턴

**어뎁터 패턴**은 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환하여 호환되지 않는 인터페이스들을 연결하여 호환되도록 하는 디자인 패턴이다.

합성된 멤버에게 위임을 이용한 객체 어뎁터 방식과 클래스 상속을 이용한 클래스 어뎁터 방식으로 나뉜다.

<br>
<br>


### facade, decorator, adapter 패턴 공통점 및 차이점

**공통점**은 구조 패턴을 사용해 ****합성을 이용했다는 점이다.

**차이점**은 아래와 같이 용도에서 차이점이 존재한다는 점이다.

- adapter는 어떤 인터페이스를 다른 인터페이스로 변환하여 **호환성**을 제공하기 위해 사용하고,
- facade는 서브 시스템에 대한 간단한 인터페이스를 제공하여 클라이언트가 서브 시스템을 간단하게 접근할 수 있도록 하기 위해 사용한다.
- decorator는 인터페이스를 다른 인터페이스로 바꾸지 않고, 기능을 추가할 때 사용한다.

<br>
<br>


### 옵저버 패턴

옵저버 패턴(observer pattern)은 주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴이다.

주체란 객체의 상태 변화를 보고 있는 관찰자이며, 옵저버들이란 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 ‘추가 변화 사항’이 생기는 객체들을 의미한다.

<br>
<br>


### SOLID 원칙

**SRP(Single Responsibility Principle) - 단일 책임 원칙**

- 한 클래스는 하나의 책임만 가져야 한다는 원칙이다. 또한 변경이 되는 이유가 하나만 존재해야 한다.

**OCP(Open-Closed Principle) - 개방 폐쇄 원칙**

- 클래스나 모듈은 확장에는 열려 있고 변경에는 닫혀 있어야 한다는 원칙이다. 즉, 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계해야 한다.
- 새로운 요구사항이나 기능이 추가될 때, 기존 코드를 수정하지 않고도 새로운 기능을 추가하거나 기존 기능을 확장하여 요구사항을 충족시키기 위해서(확장성 향상을 위해) 사용한다.

**LSP(Liskov Substitution Principle) - 리스코프 치환 원칙**

- 서브 타입은 언제나 자신의 기반(슈퍼타입)으로 대체될 수 있어야 한다는 원칙이다.
    
    즉, 다형성에서 하위 클래스는 인터페이스 규약을 지켜야 한다는 것이다.
    

**ISP(interface segregation principle) - 인터페이스 분리 원칙**

- 클라이언트는 자신이 사용하는 메서드에만 의존해야 한다. 즉, 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.

**DIP(dependency Inversion Principle) - 의존관계 역전 원칙**

- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 되며, 저수준 모듈이 고수준 모듈에 의존해야 한다는 뜻이다.
- 즉, 추상화에 의존하고, 구체화에 의존하면 안된다는 뜻이다.
    - 추상화에 의존해야 하는 이유 : 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있기 때문
