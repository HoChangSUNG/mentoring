## item 34 int 상수 대신 열거 타입을 사용하라

**열거 타입(enum type)** : 일정 개수의 상수 값을 정의한 다음, 그 이외의 값은 허용하지 않는 타입

**정수 열거 패턴(int enum pattern)** : 정수 상수를 한 묶음으로 선언해 사용

```java
public static final int APPLE_FUJI = 0;
public static final int APPLE_PIPPIN = 1;

public static final int ORANGE_NAVEL = 0;
public static final int ORANGE_TEMPLE= 1;
```
<br>

### 정수 열거 패턴 단점

- 타입 안전을 보장할 방법이 없고 표현력도 좋지 않음
- 같은 정수 열거 그룹에 속한 모든 상수를 한 바퀴 순회하는 방법도 마땅치 않음

이런 **정수 열거 패턴의 단점을 해결**하는 것이 **열거 타입**

<br>

### 열거 타입 장점

- 열거타입은 인스턴스 통제됨(싱글턴으로 생성 가능하고 동치 보장 가능)
- 컴파일 타임 타입 안전성 제공
- 열거 타입에 임의의 메서드나 필드를 추가할 수 있고 임의의 인터페이스를 구현하게 할 수도 있음

**상수별로 다르게 동작하는 코드를 구현하는 나은 수단을 제공**

- **상수별 메서드 구현 : 각 상수별 클래스 몸체(상수)에서 자신에 맞게 재정의하는 방법**
- 단점 : 열거 타입 상수끼리 코드를 공유하기 어렵다.
    - 예시)
        - 상수별 메서드 구현 적용 x
            
            ```java
            public enum Operation{
            	PLUS,MINUS
            	
            	// 상수가 뜻하는 연산을 수행
            	public double apply(double x, double y){
            		switch(this){
            			case PLUS: return x+y;
            			case MINUS: return x-y;
            		}
            		throw new AssertionError("알 수 없는 연산:" + this);
            	}
            }
            ```
            
        - 상수별 메서드 구현 적용 o
            
            ```java
            public enum Operation{
            	PLUS{public double apply(double x, double y){return x+y;}},
            	MINUS{public double apply(double x, double y){return x+y;}}
            	
            	// 상수가 뜻하는 연산을 수행
            	public abstract double apply(double x, double y)
            }
            ```
<br>            

### 상수별 메서드 구현 단점 예시 및 해결

- **단점 예시)**
    - **열거 타입 상수 일부가 같은 동작을 공유할 때** switch문을 사용하게 됨
    
    ```java
    public enum PayrollDay{
    	MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
    
    	private static final int MIN_PER_SHIFT = 8*60;
    	
    	int pay(int minutesWorked, int payRate){
    		int basePay = minutesWorked * payRate;
    
    		int overtimePay;
    		switch(this){
    			case SATURDAY: case SUNDAY: // 주말
    				overtimePay = basePay/2;
    				break;
    			default: // 주중
    				overtimePay = minutesWorked <= MIN_PER_SHIFT ? 0 : (minutesWorked - MIN_PER_SHIFT)*payRate/2;
    		}
    		return basePay + overtimePay;
    	}
    }
    ```
    
    - 기본 시급을 계산하고 주중에 오버타임이 발생하면 잔업수당을 주어짐
    - 주말에는 무조건 잔업수당이 주어짐
    
- **해결 예시)**
    - **열거 타입 상수 일부가 같은 동작을 공유할 때 switch문을 사용하지 않고 전략을 선택하도록 하는 것**
    - **새로운 상수를 추가할 때 잔업수당 ‘전략’을 선택하도록 함**
    
    ```java
    public enum PayrollDay{
    	MONDAY(WEEKDAY), TUESDAY(WEEKDAY), WEDNESDAY(WEEKDAY), THURSDAY(WEEKDAY), FRIDAY(WEEKDAY), SATURDAY(WEEKEND), SUNDAY(WEEKEND);
    
    	private final PayType payType;
    
    	PayrollDay(payType){this.payType = payType;}
    
    	int pay(int minutesWorked, int payRate){
    		return payType.pay(minutesWorked, payRate);
    	}
    
    	enum PayType{
    		WEEKEND{
    			int overtimePay(){
    				return minutesWorked * basePay/2;
    			}
    		},
    		WEEKDAY{
    			int overtimePay(){
    				return minutesWorked <= MIN_PER_SHIFT ? 0 : (minutesWorked - MIN_PER_SHIFT)*payRate/2;
    			}
    		}
    
    		abstract int overtimePay(int mins, int payRate);
    		private static final int MINS_PER_SHIFT = 8 * 60;
    
    		int pay(int minutesWorked, int payRate){
    			int basePay = minutesWorked * payRate;
    			return basePay + overtimePay(minutesWorked, payRate);
    		}
    	}
    }
    ```
    
<br>

### 열거 타입은 언제 써야 하는가?

- **필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자**
    - 태양계 행성, 한 주의 요일, 체스 말처럼 본질적으로 열거 타입인 타입은 당연히 포함
    - **열거 타입에 정의된 상수 개수가 영원히 고정 불변일 필요는 없다.**

<br>

### 핵심정리

- 열거 타입은 정수 상수(**정수 열거 패턴**)보다 뛰어남 → 더 읽기 쉽고 안전함
- 대다수의 열거타입은 명시적 생성자나 메서드 없이 쓰이지만, 각 상수를 특정 데이터와 연결짓거나 상수마다 다르게 동작하게 할 때는 필요
- 드물게 하나의 메서드가 상수별로 다르게 동작해야 할 때 switch문 대신 상수별 메서드 구현을 사용하자
    - 열거 타입 상수 일부가 같은 동작을 공유하면 전략 열거 타입 패턴을 사용하자
    
<br><br><br>

## item 35 ordinal 메서드 대신 인스턴스 필드를 사용하라

- 모든 열거 타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal 메서드를 제공함
- 하지만, 상수 선언을 바꾸는 순간 ordinal 결과가 바뀌기 때문에 사용하면 안됨
- **열거 타입 상수에 연결된 값은 ordinal 메서드로 얻지 말고 인스턴스 필드에 저장하자**
    
    ```java
    public enum Ensemble{
    	SOLO(1), DUET(2), OCTET(8), DOUBLE_QUARTET(8)
    	
    	private final int numberOfMusicians;
    	Ensemble(int size){this.numberOfMusicians = size;}
    	public int numberOfMusicians(){return numberOfMusicians;}
    }
    ```
