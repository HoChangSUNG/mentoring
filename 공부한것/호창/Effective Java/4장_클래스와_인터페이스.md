## item 15 클래스와 멤버의 접근 권한을 최소화하라

- **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다**
    - 예를 들어 public으로 선언하면 API가 되어 외부에서 사용하기 때문에 하위 호환을 위해 계속 관리해줘야 한다.
        
        하지만, 만약 패키지 외부에서 쓸 일이 없어 package-private로 선언한다면 API가 아닌 내부 구현이 되어 언제든 수정할 수 있다. 즉, 클라이언트에 아무 피해 없이 다음 릴리즈에서 수정, 교체, 제거가 가능하다.
        
- 멤버 접근성을 좁히지 못하게 방해하는 제약이 존재 → 상위 클래스의 메서드를 재정의 할때 . 그접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다는 것
    
    → 이 제약은 리스코프 치환 원칙(상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙)을 지키기 위해 필요
    
- **public 클래스의 인스턴스 필드는 되도록 public이 아니어야 함**
    - 필드가 가변 객체를 참조하거나, final이 아닌 인스턴스를 필드를 public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 됨→ 그 필드와 관련된 모든 것은 불변식을 보장할 수 없게 됨
    - **public 가변 필드를 갖는 클래스는 일반적으로 thread safe하지 않음**
- 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드는 제공하면 안됨
    - 이런 필드나 접근자를 제공하면 클라이언트에서 그 배열의 내용을 수정할 수 있게 되기 때문

### 핵심 정리

- 프로그램 요소의 접근성은 가능한 한 최소한으로 하라
- 꼭 필요한 것만 골라 최소한의 public API를 설계하자 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 함
- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안된다.
    
    public static final 필드가 참조하는 객체가 불변인지 확인해야 한다.

<br>
<br>

## item 16 public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

- public 클래스는 절대 가변 필드를 직접 노출해서는 안된다.
- 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다
    - API를 변경하지 않고는 표현방식을 바꿀 수 없고, 필드를 읽을 때 부수 작업을 수행할 수 없다는 단점이 여전히 존재
    - 단, 불변식은 보장할 수 있음
- package-private 클래스나 private 중첩 클래스에서는 종종 (불변이든 가변이든)필드를 노출하는 편이 나을 때도 있다.

<br>
<br>


## item 17 변경 가능성을 최소화하라

**불변 클래스**

- 인스턴스 내부 값을 수정할 수 없는 클래스
- 객체가 파괴되는 순간까지 정보가 달라지지 않음
- 클래스를 불변으로 만들기 위한 다섯 가지 규칙
    1. 객체의 상태를 변경하는 메서드를 제공하지 않는다
    2. 클래스를 확장할 수 없도록 한다.
    3. 모든 필드를 final로 선언한다
    4. 모든 필드를 private으로 선언한다.
    5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

**불변 객체의 장점**

- 스레드 안전하여 따로 동기화할 필요가 없음 → 안심하고 공유가능
- 실패 원자성을 제공 → 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없음
    - 실패 원자성 : 메서드에서 예외가 발생한 후에도 그 객체는 여전히(메서드 호출 전과 똑같은) 유효한 상태여야 한다는 성질

**불변 객체의 단점**

- 값이 다르면 반드시 독립된 객체로 만들어야 함

**클래스를 확장(상속)할 수 없게 하는 방법 2가지**

- final 클래스로 선언
- 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공하는 방법 → 더 유연(패키지 바깥의 클라이언트에서 바라본 이 불변 객체는 사실상 final임)

### **정리**

- 클래스는 꼭 필요한 경우가 아니면 불변이어야 한다 → 불변 클래스의 장점은 많고 단점은 특정 상황에서의 잠재적 성능 저하 뿐이다.
- 한편, 모든 클래스를 불변으로 만들 수는 없다 → 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자 → 객체가 가질 수 있는 상태를 줄이면 그 객체를 예측하기 쉬워져서 오류가 생길 가능성이 줄음
    - 다른 합당한 이유가 없으면 모든 필드는 private final이어야 함
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.

<br>
<br>


## item 18 상속보다는 컴포지션을 사용하라

- **메서드 호출과 달리 상속은 캡슐화를 깨뜨린다 → 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.**
- 이러한 상속의 문제를 해결하는 방법 → 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하자
    
    → 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이런 설계를 **컴포지션**이라고 함
    
    - 전달(forwarding) : 새 클래스의 인스턴스 메서드들은 기존 클래스(private 필드로 참조하는)에 대응하는 메서드를 호출해 그 결과를 반환
    - 전달 메서드(forwarding method) : 새 클래스의 메서드들
    - 이런 방식을 통해 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향을 벗어나며, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향을 받지 않는다.
- 컴포지션을 써야 할 상황에서 상속을 사용했을 때 문제
    - 내부 구현을 불필요하게 노출하는 꼴 → 클라이언트가 노출된 내부에 직접 접근할 수 있음
    - 클라이언트에서 상위 클래스를 직접 수정하여 하위 클래스의 불변식을 해칠 수 있다는 사실
- 컴포지션 대신 상속을 사용하기로 결정하기 전에 생각해보아야 하는 점
    - 확장하려는 클래스의 API에 아무런 결함이 없는가? 를 확인해 보야아 함 → 컴포지션으로는 API의 결함을 숨기는 새로운 API 클래스를 설계할 수 있지만, 상속은 API의 결함까지 그대로 승계하기 때문이다

### 핵심 정리

- 상속은 강력하지만 캡슐화를 해친다는 문제가 존재
- 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자.
    
    특히 래퍼 클래스로 구현한 적당한 인터페이스가 있다면 더욱 그렇다, 래퍼 클래스는 하위 클래스보다 견고하고 강력하다.
    
<br>
<br>



## item 19 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

- 상속을 고려한 설계와 문서화란 정확하게 무얼 뜻할까?
    - 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기 사용) 문서로 남겨야 한다는 뜻
    - 더 넓게 말하면 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
- 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있음
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 함
- 상속용 클래스의 생성자는 직접적이든 간접적이든 재정의 가능 메서드를 호출해서는 안됨 → 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되어 하위 클래스에서 재정의한 메서드가 하위 클래스의 생서자보다 먼저 호출되어 의도한대로 동작하지 않을 수 있기 때문
- 일반적인 구체 클래스는 final도 아니고 상속용으로 설계되지도 않았는데, 어떤 클라이언트가 구체 클래스를 상속해서 문제가 생길 수 있는데 어떻게 해결해야 할까?
    - 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이 것 → final로 클래스를 선언하는 방법, 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만들어주는 방법
        - 두번째 방법인 정적 팩터리 방법은 내부에서 다양한 하위 클래스를 만들어 쓸 수 있는 유연성을 줄 수 있음

### 핵심 정리

- 상속용 클래스로 설계 시 클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야 하고, 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 함
    
    그렇지 않으면, 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오작동하게 만들 수 있음
    
- 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나음
    - 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록(생성자를 private/package-private로 만들고 public 정적 팩터리를 사용) 만들면 됨

<br>
<br>


## item 20 추상 클래스보다는 인터페이스를 우선하라

- 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있고 **믹스인 정의에 안성 맞춤이다(추상 클래스는 믹스인 정의 못함)**
    - 믹스인(mixed in)
        - 클래스가 구현할 수 있는 타입, 대상 타입의 주된 기능에 선택적 기능을 혼합해서 믹스인이라고 부름
    - 믹스인을 구현한 클래스에 원래의 주된 타입 외에 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.
        - 예를 들어 Comparable은 자신을 구현한 클래스의 인스턴스끼드는 순서를 정할 수 있다고 선언한 믹스인 인터페이스
    - **추상 클래스로는 믹스인을 정의할 수 없음** → 다중 상속이 불가능…

- 인터페이스 메서드 중 구현 방법이 명백한 것이 있으면, 그 구현을 디폴트 메서드로 제공해 프로그래머들 일감을 줄일 수 있음
    - 하지만 디폴트 메서드에는 제약이 존재
        1. equals, hashCode와 같은 Object의 메서드는 디폴트 메서드로 제공해서는 안됨
        2. 인터페이스는 인스턴스 필드를 가질 수 없고 public이 아닌 정적 멤버도 가질 수 없음(private 정적 메서드는 예외)
        3. 내가 만들지 않은 인터페이스에는 디폴트 메서드를 추가할 수 없음
- 인터페이스의 디폴트 메서드에 존재하는 제약으로 인해 인터페이스와 추상 골격 구현(skeletal implementation 클래스를 함께 제공 → 인터페이스와 추상 클래스의 장점을 모두 취함
    - 인터페이스로 타입을 정의하고, 필요하면 디폴트 메서드 몇개도 함께 제공, 골격 구현 클래스는 나머지 메서드들까지 구현
        
        → 이렇게 하면 단순히 골격 구현을 확장하는 것만으로도 이 인터페이스를 구현하는데 필요한 일이 대부분 완료됨
        
        → 이것이 바로 **템플릿 메서드 패턴**
        

### 핵심 정리

- 일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합
- 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법도 고려해보자
- 골격 구현은 ‘가능한 한’ 인터페이스의 디폴트 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋다
    - ‘가능한 한’ 이라고 한 이유는, 인터페이스에 걸려 있는 구현상의 제약 때문에 골격 구현을 추상 클래스로 제공하는 경우가 더 흔하기 때문
 
<br>
<br>

## item 21 인터페이스는 구현하는 쪽을 생각해 설계하라

- 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기는 어렵다
    - 예시로 SynchronizedCollection 클래스는 removeIf 메서드를 재정의하지 않아 디폴트 메서드로 정의된 removeIf 메서드를 사용한다.
    - 하지만 이럴 경우 SynchronizedCollection은 모든 메서드 호출을 알아서 동기화해주지 못한다.
    - 따라서 SynchronizedCollection 인스턴스를 멀티 스레드 환경에서 한 스레드가 removeIf를 호출하면 ConcurrentModificationException이 발생하거나 다른 예기치 못한 결과로 이어진다.
- 또한 디폴트 메서드(컴파일에 성공하더라도)는 흔하지는 않지만 기존 구현체에 런타임 오류를 일으킬 수도 있다.
- 디폴트 메서드는 표준적인 메서드 구현을 제공해주는 장점이 있다.
    
    하지만 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 용도는 아님을 명심해야 한다
    
- **핵심은 인터페이스에 디폴트 메서드라는 도구가 생겼더라도 인터페이스 설계할 대는 여전히 세심한 주의를 기울여야 한다.**
 
<br>
<br>

## item 22 인터페이스 타입을 정의하는 용도로만 사용하라

- 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다.
    
    다시 말해, 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기하는 것이다.
    
    따라서 인터페이스는 위 용도로만 사용해야 한다.
    
- **위 지침에 맞지 않는 예로 상수 인터페이스**가 존재 → **상수 인터페이스는 인터페이스를 잘못 사용한 예**
    - 상수 인터페이스는 : 메서드 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스
    - 예시
        
        ```java
        public interface PhysicalConstants{
        	static final double AVOGADROS_NUMBER = 6.022_140_857e23;
        	static final double BOLTZMANN_CONSTANT = 1.380_648+52e-23;
        }
        ```
        
    - 잘못된 이유는?
        - 클래스에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현이고, 이 내부 구현을 클래스의 API로 노출하는 행위이기 때문
        - final이 아닌 클래스가 상수 인터페이스를 구현하면 모든 하위 클래스의 이름 공간이 인터페이스가 정의한 상수들로 오염되어 버림
        
- **그렇다면 상수를 공개할 목적이라면 좋은 방법은 무엇이 있을까?**
    1. 특정 클래스나 인터페이스와 강하게 연결된 상수라면 그 클래스나 인터페이스 자체에 추가해야 함
        - 예시) Integer와 Double에 선언된 MIN_VALUE, MAX_VALUE 상수
    2. 열거 타입으로 나타내기 적합한 상수라면 열거 타입으로 만들어 공개
    3. 인스턴스화 할 수 없는 유틸리티 클래스에 담아 공개
        - 예시)
            
            ```java
            public class PhysicalConstants{
            	private PhysicalConstants(){}
            	
            	public static final double AVOGADROS_NUMBER = 6.022_140_857e23;
            	public static final double BOLTZMANN_CONSTANT = 1.380_648+52e-23;
            }
            ```
            

### 핵심 정리

- 인터페이스는 타입을 정의하는 용도로만 사용해야 한다.
- 상수 공개용 수단으로 사용하지 말자.
 
<br>
<br>

## item 23 태그 달린 클래스보다는 클래스 계층 구조를 활용하라

두 가지 이상의 의미를 표현할 수 있고, 그 중 현재 표현하는 의미를 태그 값으로 알려주는 클래스를 태그 달린 클래스라고 한다.

**태그 달린 클래스 예시**

```java
class Figure{
	enum Shape {RECTANGLE, CIRCLE}
	final Shpae shape;

	// 모양이 사각형(RECTANGLE)일때만 사용
	double length;
	double width;
	// 모양이 원(CIRCLE)일 때만 사용
	double radius

	// 원(RECTANGLE)용 생성자
	Figure(double radius){...}
	// 사각형(CIRCLE)용 생성자
	Figure(double length, double width){...}
	
	double area(){...}
}
```

**태그 달린 클래스 단점**

- 여러 구현이 한 클래스에 혼합되어 있어 가독성이 나쁨
- 다른 의미(구현)를 위한 코드도 언제나 함께 작성되어 있어 불필요한 메모리 사용
- **즉, 태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적임**

**태그 달린 클래스는 클래스 계층 구조를 어설프게 흉내낸 아류일 뿐 → 클래스 계층 구조를 사용하자**

**클래스 계층 구조를 사용할 때 장점**

- 루트 클래스의 코드를 건드리지 않고도 다른 프로그래머들이 독립적으로 계층구조를 확장하고 사용할 수 있음
- 타입 사이의 자연스러운 계층 관계를 반영할 수 있어 유연성과 컴파일타임 타입 검사 능력을 높여줌

### 핵심 정리

- 태그 달린 클래스를 써야 하는 상황은 거의 없음
- 새로운 클래스를 작성하는 데 태그 필드가 등장한다면 태그를 없애고 계층 구조로 대체하는 방법을 생각해보자
- 기존 클래스가 태그 필드를 사용하고 있다면 계층 구조로 리팩터링하는 걸 고민하자
 
<br>
<br>

## item 24 멤버 클래스는 되도록 static으로 만들라

중첩 클래스 종류 및 사용 시기

- 정적 멤버 클래스
    - 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 쓰임
- (비정적) 멤버 클래스
    - 어댑터를 정의할 때 자주 사용
        - 즉, 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용 (Map.keySet, entrySet, value 메서드가 반환하는 컬렉션 뷰)
- 익명 클래스
    - 람다를 지원하기 전에는 즉석에서 작은 함수 객체나 처리 객체를 만드는데 주로 사용함
        - 람다가 생기고 나서는 람다가 이 역할을 대신함
    - 정적 팩터리 메서드를 구현할 때 사용
- 지역 클래스
    - 가장 드물게 사용

**멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자**

- **왜** 그래야 하는가?
    - static 생략 시 바깥 인스턴스로의 숨은 외부 참조를 가지게 되고, 이 참조를 저장하려면 시간과 공간이 소비된다는 문제 때문
    - 더 심각한 문제는 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못하는 메모리 누수가 생길 수 있다는 점 때문

### 핵심 정리

- 중첩 클래스는 멤버 클래스, 정적 멤버 클래스, 익명 클래스, 지역 클래스가 존재
- (비정적)**멤버 클래스** → 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 긴 경우
- **정적 멤버 클래스** → 바깥 인스턴스를 참조하지 않는 경우
- **익명 클래스** → 중첩 클래스가 한 메서드 안에서만 사용되면서 그 인스턴스를 생성하는 지점이 한 곳이고 해당 타입으로 쓰기에 적절한 클래스나 인터페이스가 이미 있는 경우
- **지역 클래스** → 위의 경우들에 해당하지 않는 경우
 
<br>
<br>

## item 25 톱레벨 클래스는 한 파일에 하나만 담으라

- 소스 파일 하나에 톱레벨 클래스를 여러 개 선언해도 자바 컴파일러는 문제 삼지 않는다
    
    하지만, 심각한 위험을 감수해야 하는 행위이다.
    
    **위처럼 하면 한 클래스를 여러 가지로 정의할 수 있으며, 그중 어느 것을 사용할지는 어느 소스 파일이 먼저 컴파일하냐에 따라 달리지기 때문이다.**
    

- 예시
    
    **`Utensil.java`**
    
    ```java
    class Utensil{
    	static final String NAME = "pan";
    }
    
    class Dessert{
    	static final String NAME = "cake";
    }
    ```
    
    **`Dessert.java`**
    
    ```java
    class Utensil{
    	static final String NAME = "pot";
    }
    
    class Dessert{
    	static final String NAME = "pie";
    }
    ```
    
    ```java
    public class Main{
    	public static void main(String[] args){
    		System.out.println(Utensil.NAME + Desert.NAME);
    	}
    }
    
    ```
    
    - `javac Main.java Utensil.java`로 컴파일할 경우는 **pancake를 출력**하지만, `javac Dessert.java Main.java`로 컴파일 할 경우 **potpie 가 출력**된다
    - **이처럼 컴파일러에 어느 소스 파일을 먼저 건네느냐에 따라 동작이 달라지므로 반드시 잡아야 할 문제이다**

### 핵심정리

- 중요한 것은 소스 파일 하나에는 반드시 톱레벨 클래스(혹은 톱레벨 인터페이스)를 하나만 담자
- 이 규칙을 따르면 소스 파일을 어떤 순서로 컴파일하든 바이너리 파일이나 프로그램의 동작이 달라지는 일은 일어나지 않는다.
