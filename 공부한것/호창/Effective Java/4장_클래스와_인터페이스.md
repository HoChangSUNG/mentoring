## item 15 클래스와 멤버의 접근 권한을 최소화하라

- **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다**
    - 예를 들어 public으로 선언하면 API가 되어 외부에서 사용하기 때문에 하위 호환을 위해 계속 관리해줘야 한다.
        
        하지만, 만약 패키지 외부에서 쓸 일이 없어 package-private로 선언한다면 API가 아닌 내부 구현이 되어 언제든 수정할 수 있다. 즉, 클라이언트에 아무 피해 없이 다음 릴리즈에서 수정, 교체, 제거가 가능하다.
        
- 멤버 접근성을 좁히지 못하게 방해하는 제약이 존재 → 상위 클래스의 메서드를 재정의 할때 . 그접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다는 것
    
    → 이 제약은 리스코프 치환 원칙(상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙)을 지키기 위해 필요
    
- **public 클래스의 인스턴스 필드는 되도록 public이 아니어야 함**
    - 필드가 가변 객체를 참조하거나, final이 아닌 인스턴스를 필드를 public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 됨→ 그 필드와 관련된 모든 것은 불변식을 보장할 수 없게 됨
    - **public 가변 필드를 갖는 클래스는 일반적으로 thread safe하지 않음**
- 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드는 제공하면 안됨
    - 이런 필드나 접근자를 제공하면 클라이언트에서 그 배열의 내용을 수정할 수 있게 되기 때문

### 핵심 정리

- 프로그램 요소의 접근성은 가능한 한 최소한으로 하라
- 꼭 필요한 것만 골라 최소한의 public API를 설계하자 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 함
- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안된다.
    
    public static final 필드가 참조하는 객체가 불변인지 확인해야 한다.

<br>
<br>

## item 16 public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

- public 클래스는 절대 가변 필드를 직접 노출해서는 안된다.
- 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다
    - API를 변경하지 않고는 표현방식을 바꿀 수 없고, 필드를 읽을 때 부수 작업을 수행할 수 없다는 단점이 여전히 존재
    - 단, 불변식은 보장할 수 있음
- package-private 클래스나 private 중첩 클래스에서는 종종 (불변이든 가변이든)필드를 노출하는 편이 나을 때도 있다.

<br>
<br>


## item 17 변경 가능성을 최소화하라

**불변 클래스**

- 인스턴스 내부 값을 수정할 수 없는 클래스
- 객체가 파괴되는 순간까지 정보가 달라지지 않음
- 클래스를 불변으로 만들기 위한 다섯 가지 규칙
    1. 객체의 상태를 변경하는 메서드를 제공하지 않는다
    2. 클래스를 확장할 수 없도록 한다.
    3. 모든 필드를 final로 선언한다
    4. 모든 필드를 private으로 선언한다.
    5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

**불변 객체의 장점**

- 스레드 안전하여 따로 동기화할 필요가 없음 → 안심하고 공유가능
- 실패 원자성을 제공 → 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없음
    - 실패 원자성 : 메서드에서 예외가 발생한 후에도 그 객체는 여전히(메서드 호출 전과 똑같은) 유효한 상태여야 한다는 성질

**불변 객체의 단점**

- 값이 다르면 반드시 독립된 객체로 만들어야 함

**클래스를 확장(상속)할 수 없게 하는 방법 2가지**

- final 클래스로 선언
- 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공하는 방법 → 더 유연(패키지 바깥의 클라이언트에서 바라본 이 불변 객체는 사실상 final임)

### **정리**

- 클래스는 꼭 필요한 경우가 아니면 불변이어야 한다 → 불변 클래스의 장점은 많고 단점은 특정 상황에서의 잠재적 성능 저하 뿐이다.
- 한편, 모든 클래스를 불변으로 만들 수는 없다 → 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자 → 객체가 가질 수 있는 상태를 줄이면 그 객체를 예측하기 쉬워져서 오류가 생길 가능성이 줄음
    - 다른 합당한 이유가 없으면 모든 필드는 private final이어야 함
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.

<br>
<br>


## item 18 상속보다는 컴포지션을 사용하라

- **메서드 호출과 달리 상속은 캡슐화를 깨뜨린다 → 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.**
- 이러한 상속의 문제를 해결하는 방법 → 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하자
    
    → 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이런 설계를 **컴포지션**이라고 함
    
    - 전달(forwarding) : 새 클래스의 인스턴스 메서드들은 기존 클래스(private 필드로 참조하는)에 대응하는 메서드를 호출해 그 결과를 반환
    - 전달 메서드(forwarding method) : 새 클래스의 메서드들
    - 이런 방식을 통해 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향을 벗어나며, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향을 받지 않는다.
- 컴포지션을 써야 할 상황에서 상속을 사용했을 때 문제
    - 내부 구현을 불필요하게 노출하는 꼴 → 클라이언트가 노출된 내부에 직접 접근할 수 있음
    - 클라이언트에서 상위 클래스를 직접 수정하여 하위 클래스의 불변식을 해칠 수 있다는 사실
- 컴포지션 대신 상속을 사용하기로 결정하기 전에 생각해보아야 하는 점
    - 확장하려는 클래스의 API에 아무런 결함이 없는가? 를 확인해 보야아 함 → 컴포지션으로는 API의 결함을 숨기는 새로운 API 클래스를 설계할 수 있지만, 상속은 API의 결함까지 그대로 승계하기 때문이다

### 핵심 정리

- 상속은 강력하지만 캡슐화를 해친다는 문제가 존재
- 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자.
    
    특히 래퍼 클래스로 구현한 적당한 인터페이스가 있다면 더욱 그렇다, 래퍼 클래스는 하위 클래스보다 견고하고 강력하다.
    
<br>
<br>



## item 19 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

- 상속을 고려한 설계와 문서화란 정확하게 무얼 뜻할까?
    - 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기 사용) 문서로 남겨야 한다는 뜻
    - 더 넓게 말하면 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.
- 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있음
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 함
- 상속용 클래스의 생성자는 직접적이든 간접적이든 재정의 가능 메서드를 호출해서는 안됨 → 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되어 하위 클래스에서 재정의한 메서드가 하위 클래스의 생서자보다 먼저 호출되어 의도한대로 동작하지 않을 수 있기 때문
- 일반적인 구체 클래스는 final도 아니고 상속용으로 설계되지도 않았는데, 어떤 클라이언트가 구체 클래스를 상속해서 문제가 생길 수 있는데 어떻게 해결해야 할까?
    - 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이 것 → final로 클래스를 선언하는 방법, 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩터리를 만들어주는 방법
        - 두번째 방법인 정적 팩터리 방법은 내부에서 다양한 하위 클래스를 만들어 쓸 수 있는 유연성을 줄 수 있음

### 핵심 정리

- 상속용 클래스로 설계 시 클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야 하고, 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 함
    
    그렇지 않으면, 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오작동하게 만들 수 있음
    
- 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나음
    - 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록(생성자를 private/package-private로 만들고 public 정적 팩터리를 사용) 만들면 됨

<br>
<br>


## item 20 추상 클래스보다는 인터페이스를 우선하라

- 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있고 **믹스인 정의에 안성 맞춤이다(추상 클래스는 믹스인 정의 못함)**
    - 믹스인(mixed in)
        - 클래스가 구현할 수 있는 타입, 대상 타입의 주된 기능에 선택적 기능을 혼합해서 믹스인이라고 부름
    - 믹스인을 구현한 클래스에 원래의 주된 타입 외에 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.
        - 예를 들어 Comparable은 자신을 구현한 클래스의 인스턴스끼드는 순서를 정할 수 있다고 선언한 믹스인 인터페이스
    - **추상 클래스로는 믹스인을 정의할 수 없음** → 다중 상속이 불가능…

- 인터페이스 메서드 중 구현 방법이 명백한 것이 있으면, 그 구현을 디폴트 메서드로 제공해 프로그래머들 일감을 줄일 수 있음
    - 하지만 디폴트 메서드에는 제약이 존재
        1. equals, hashCode와 같은 Object의 메서드는 디폴트 메서드로 제공해서는 안됨
        2. 인터페이스는 인스턴스 필드를 가질 수 없고 public이 아닌 정적 멤버도 가질 수 없음(private 정적 메서드는 예외)
        3. 내가 만들지 않은 인터페이스에는 디폴트 메서드를 추가할 수 없음
- 인터페이스의 디폴트 메서드에 존재하는 제약으로 인해 인터페이스와 추상 골격 구현(skeletal implementation 클래스를 함께 제공 → 인터페이스와 추상 클래스의 장점을 모두 취함
    - 인터페이스로 타입을 정의하고, 필요하면 디폴트 메서드 몇개도 함께 제공, 골격 구현 클래스는 나머지 메서드들까지 구현
        
        → 이렇게 하면 단순히 골격 구현을 확장하는 것만으로도 이 인터페이스를 구현하는데 필요한 일이 대부분 완료됨
        
        → 이것이 바로 **템플릿 메서드 패턴**
        

### 핵심 정리

- 일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합
- 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법도 고려해보자
- 골격 구현은 ‘가능한 한’ 인터페이스의 디폴트 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋다
    - ‘가능한 한’ 이라고 한 이유는, 인터페이스에 걸려 있는 구현상의 제약 때문에 골격 구현을 추상 클래스로 제공하는 경우가 더 흔하기 때문 
