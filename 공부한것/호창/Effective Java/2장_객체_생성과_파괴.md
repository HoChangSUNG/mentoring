# 2장 객체 생성과 파괴

## item 1 생성자 대신 정적 팩터리 메서드를 고려하라

- 클래스는 생성자(public 생성자)와 별도로 정적 팩터리 메서드를 제공할 수 있음

### 정적 팩토리 메서드가 생성자보다 좋은 장점 5가지

1. 이름을 가질 수 있다. → 생성자는 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하지 못하지만, 정적 팩터리 메서드는 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있음
    - BigInteger(int, int, Random) 과 BigInteger.probablePrime(int,int, Random) 중 후자가 값이 소수인 BigInteger를 반환한다는 의미를 더 잘 설명할 수 있음
2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
    - 이 덕분에 불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있음
        - Boolean.valueOf(boolean) 메서드는 객체를 아예 생성하지 않음
    - 정적 팩토리 방식의 클래스는 언제 어느 인스턴스가 살아 있게 할지를 통제할 수 있는데 이런 클래스를 **인스턴스 통제 클래스**라고 함
        - 인스턴스를 통제하려고 하는 이유?
            - 클래스를 싱글톤으로 만들 수 있고, 인스턴스화 불가로 만들 수 있고, 불변 값 클래스에서 동치인 인스턴스가 단 하나뿐임(a==b일때만, a.equals(b)가 성립)을 보장할 수 있음
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
    - 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 엄청난 유연성을 선물한다.
        - API를 만들 때 이 유연성을 응용하면 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있다.
    - 나아가 정적 팩토리 메서드를 사용하는 클라이언트는 얻은 객체를 (그 구현 클래스가 아닌) 인터페이스만으로 다루게 된다.
4. 입력 매개변수에 따라 매번 다른 클래스와 객체를 반환할 수 있다.
    - 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다ㅏ.

### 정적 팩토리 메서드 단점 2가지

1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다.
2. 정적 팩토리 메서드는 프로그래머가 찾기 힘들다.
    - 생성자처럼 API설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야 한다.

### 핵심 정리

- 정적 팩터리 메서드와 public 생성자는 각자 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다.
- 그렇다고 해도 정적 팩터리를 사용하는 것이 유리한 경우가 더 많음

<br>
<br>

## item 2 생성자에 매개변수가 많다면 빌더를 고려하라

- 정적 팩토리와 생성자는 선택적 매개변수가 많을 때 적절히 대응하기 어렵다는 제약이 존재
- 이 제약을 대응하기 위한 대안 3가지
    1. 점층적 생성자 패턴
    2. 자바빈즈 패턴
    3. 빌더 패턴

### 점층적 생성자 패턴

- 필수 매개변수만 받는 생성자, 필수 매개변수와 선택 매개변수 1개를 받는 생성자, 선택 매개변수를 2개 받는 생성자 … 형태로 선택 매개변수를 번부 받는 생성자까지 늘려가는 방식

    ```jsx
    public class nutritionFacts{
    	private final int servingSize;
    	private final int calories;
    	private final int sodium;
    	public nutritionFacts(int servingSize){...}
    	public nutritionFacts(int servingSize,int calories){...}
    	public nutritionFacts(int servingSize,int calories,int sodium){...}
    }
    ```

- 사용자가 설정하길 원치 않는 매개변수까지 포함하기 쉽고 어쩔 수 없이 설정하길 원치 않는 매개변수에도 값을 지정해줘야 하는 경우도 생김
- 즉, 매개 변수가 많아지면 클라이언트 코드를 작성하거나 읽기 어려워짐

### 자바빈즈 패턴

- 매개변수가 없는 생성자로 객체를 만든 후 setter 메서드들을 호출해 원하는 매개변수의 값을 설정하는 방식
- 단점 → 객체 하나를 만들려면 메서드를 여러 개 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태로 놓이게 됨

    ```java
    nutritionFacts cola = new nutritionFacts();
    cola.setServingSize(240);
    cola.setCalories(240);
    cola.setSodium(240);
    ```


### 빌더 패턴

- 점층적 생성자 패턴의 안전성과 자바빈즈 패턴의 가독성을 겸비
- 클라이언트는 필요한 객체를 직접 만드는 대신, 필수 매개변수만으로 생성자(혹은 정적 팩토리)를 호출해 빌더 객체를 얻고, 빌더 객체가 제공하는 일종의 세터 메서드들로 원하는 선택 매개변수들을 설정
- 빌더 이용시 가변 인수 매개변수를 여러 개 사용할 수 있다.
- **단점**
    - 객체를 생성하려면, 빌더부터 만들어야 함  → 성능에 민감한 상황이라면 문제가 될 수 있음
    - 점층적 생성자 패턴보다는 코드가 장황해서 매개변수가 4개 이상은 되어야 값어치를 한다.

      하지만, API는 시간이 지날수록 매개변수가 많아지는 경향이 있음을 명심해야 함.


### 핵심 정리

- 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는 게 더 낫다
    - 매개 변수 중 다수가 필드가 아니거나 같은 타입이면 특히 더 그렇다.
- 빌더는 점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈즈보다 훨씬 안전하다.

**불변식**

- 프로그램이 실행되는 동안, 혹은 정해진 기간 동안 반드시 만족해야 하는 조건

  다시 말해 변경을 허용할 수는 있으나 주어진 조건 내에서만 허용한다는 뜻

  예를 들어 리스트의 크기는 반드시 0 이상이어야 하니, 만약 한순간이라도 음수 값이 되면 불변식이 깨진 것


**공변 반환 타이핑(convariant return typing)**

- 하위 클래스의 메서드가 상위 클래스의 메서드가 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 기능

<br>
<br>


## item 3 private 생성자나 열거 타입으로 싱글턴임을 보증하라

- 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기 어려워질 수 있음
    - 타입을 인터페이스로 정한 다음 그 인터페이스를 구현해서 만든 싱글톤이 아니라면 싱글턴 인스턴스를 가짜 구현으로 대체할 수 없기 때문
- 싱글턴을 만드는 방법 3가지
    1. public static 멤버가 final 필드인 방식

        ```java
        public class Elvis{
        	**public static final Elvis INSTANCE = new Elvis();**
        	private Elvis(){...}
        }
        ```

        - 싱글톤 인스턴스에 접근할 수 있는 수단으로 public static final 멤버를 사용
        - 장점 → 해당 클래스가 싱글턴임이 API에 명백히 드러남, 간결함
    2. 정적 팩터리 메서드를 public static 멤버로 제공하는 방식

        ```java
        public clss Elvis{
        	private static final Elvis INSTANCE = new Elvis();
        	private Elvis(){...}
        	private static ELvis getInstance(){return INSTANCE;}
        }
        ```

        - 장점
            - API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다는 점(호출하는 스레드별로 다른 인스턴스를 넘겨줄 수 있음)
            - 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다는 점(item 30)
            - 정적 팩터리의 메서드 참조를 공급자(supplier)로 사용할 수 있다는 점(item 43,44)
    3. 원소가 하나인 열거 타입을 선언하는 방식

        ```java
        public enum Elvis{
        	INSTANCE;
        }
        ```

        - 리플랙션 공격에서도 제 2의 인스턴스가 생기는 일을 막아줌
        - 부자연스러워 보일 수 있으나 대부분의 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법
            - 단, 만들려는 싱글턴이 enum외의 클래스를 상속해야 한다면 이 방법은 사용할 수 없음

<br>
<br>


## item 4 인스턴스화를 막으려거든 private 생성자를 사용하라

- 클래스의 인스턴스화를 막으려면 private 생성자를 사용해야 한다
    - 이유 : 생성자를 명시하지 않으면 public 생성자가 기본으로 생성되기 때문
- 추상 클래스로 만드는 것은 인스턴스화를 막을 수 없음
    - 이유
        - 추상 클래스를 상속하는 하위 클래스를 만들고 인스턴스화할 수 있기 때문
        - 또한, 추상 클래스를 쓰면 상속해서 쓰라는 의미로 오해할 수 있음
- 상속을 불가능하게 하는 효과가 존재
    - 모든 생성자는 상위 클래스의 생성자를 호출해야 하는데, private로 선언되어 있어 하위 클래스가 상위 클래스의 생성자로 접근할 방법이 막혀버리기 때문

<br>
<br>


## item 5 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

- 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다.
- 이 자원들을 클래스가 직접 만들게 해서도 안되고 대신 필요한 자원을(혹은 그 자원을 만들어주는 팩터리를) 생성자(혹은 정적 팩토리나 빌더)에 넘겨주자
- 이렇게 의존 객체 주입을 통해 클래스의 유연성,  재사용성, 테스트 용이성을 개선해준다.

<br>
<br>


## item 6 불필요한 객체 생성을 피하라

- 똑같은 기능의 객체를 매번 생성하기보다 객체 하나를 재사용하는 편이 나을 때가 많음
- 아래는 불필요한 객체 생성을 하는 예시들
    - String s = new String(”bikini”);
        - 문장이 실행될 때마다 String 인스턴스를 새로 만들게 됨
    - Boolean(String) 생성자를 이용해 생성
        - 위 대신 Boolean.valueOf(String) 팩터리 메서드를 사용해서 생성하는 것이 좋음 →생성자는 호출할 때마다 새로운 객체를 생성하지만 팩터리 메서드를 통해 생성하면 이미 생성된 객체를 리턴
    - 생성 비용이 비싼 객체 → 정규표현식 표현하는 Pattern 클래스가 생성 비용이 비싼 객체의 예시
        - 반복해서 필요할 경우 캐싱하여 사용하는 것을 권장


<br>
<br>


## item 7 다 쓴 객체 참조를 해제하라

- 자바는 가비지 컬렉터로 메모리 관리에 신경 쓰지 않아도 된다고 오해하는 경우가 존재
- 메모리 누수가 발생할 수 있기 때문에 다 쓴 객체 참조를 해제하여 메모리 관리를 해야 함
- 예시

    ```java
    public class Stack{
    	private Object[] elements;
    	private int size = 0;
    	private static final int DEFAULT_INITIAL_CAPACITY = 16;
    	
    	public Stack(){...}
    	public void push(Object e){
    		ensureCapacity();
    		elements[size++] = e;
    	}
    	public Object pop(){
    		if(size==0) throw new EmptyStackException();
    		return elements[--size];
    	}
    }
    ```

    - 위 코드의 메모리 누수 원인
        - 스택이 커졌다가 줄어들 때 스택에서 꺼내진 객체들은 가비지 컬렉터가 회수하지 않기 때문
            - 스택이 앞으로 다시 쓰지 않을 참조를 여전히 가지고 있어, 가비지 컬렉터는 그 참조가 유효하다고 판단하기 때문
    - 해결 방법
        - 앞으로 사용하지 않을 참조를 전부 null 처리 해줌 → 가비지 컬렉터에게 더 이상 해당 객체를 사용하지 않을 것임을 알려줌
- 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.
    - 다쓴 참조 를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효범위 밖으로 밀어내는 것
    - **자기 메모리를 직접 관리하는 경우** 다 쓴 메모리를 null처리 해야 함.

- 캐시, 리스너 혹은 콜백이 메모리 누수의 주범중 하나이다
    - 캐시 → 객체 참조를 캐시에 넣고, 캐시에 객체 참조를 넣었다는 사실을 잊은 채 그 객체를 다 쓴 뒤로도 그냥 놔두는 경우 → wakHashMap을 사용
    - 리스너 혹은 콜백 → 클라이언트가 콜백을 등록만 하고 명확히 해지하지 않으면 콜백은 계속 쌓여만 감 → wakHashMap에 키로 저장하면 약한 참조로 저장되어 가비지 컬렉터가 즉시 수거

### 강한 참조 vs 약한 참조

**강한 참조**

- 일반적으로 객체를 참조할 때 사용
- 해당 객체가 메모리에서 사용 중일 경우 가비지 컬렉터가 해당 객체를 제거하지 않음
- 객체가 더 이상 사용되지 않을 때, 해당 객체에 대한 모든 참조가 해제되면 가비지 컬렉터가 이를 감지하여 메모리에서 제거

**약한 참조**

- 약한 참조는 가비지 컬렉션의 대상이 됨
- 해당 객체에 대한 참조를 가지고 있지만, 해당 객체가 다른 강한 참조 없이 남아있는 경우 가비지 컬렉터에 의해 수거될 수 있음
- 주로 캐시나 대규모 데이터 구조에서 사용하여 메모리 누수를 방지하는 데 유용

[참고 자료](https://bepoz-study-diary.tistory.com/340)

<br>
<br>


## item 8 finalizer와 cleaner 사용을 피하라

- 자바는 finalizer, cleaner라는 두가지 객체 소멸자를 제공.
- finalizer와 cleaner 문제
    1. 이 두 개의 객체 소멸자는 위험하고 예측할 수 없고 느리기 때문에 일반적으로 불필요
        - finalizer, cleaner는 즉시 수행된다는 보장이 없음

          즉, finalizer와 cleaner로는 제때 실행되어야 하는 작업은 절대 할 수 없음

          예시로 파일 닫기를 finalizer나 cleaner에게 맡기면 새로운 파일을 열지 못해 프로그램이 실패할 수 있음

            - 시스템이 동시에 열 수 있는 파일 개수에 한계가 있어, 파일 닫기를 제때 실행하지 안고 파일을 계속 열어둘 수 있어서
        - finalizer, cleaner는 수행이 된다는 수행 여부조차 보장하지 않음
        - finalizer 동작 중 발생한 예외는 무시되고 처리할 작업이 남았더러라도 그 순간 종료됨
    2. finalizer와 cleaner는 심각한 성능 문제도 동반한다.
        - finalizer가 가비지 컬렉터의 효율을 떨어뜨리기 때문
    3. finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다.
        - 객체 생성을 막으려면 생성자에서 예외를 던지는 것만으로 충분하지만, finalizer가 있다면 그렇지 않음
        - final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무 일도 하지 않는 finalize 메서드를 만들고 final로 선언하자


### finalizer와 cleaner의 적절한 쓰임새

1. 자원의 소유자가 close 메서드를 호출하지 않은 것에 대비한 안전망 역할
    - finalizer와 cleaner가 즉시(혹은 끝까지)호출되리라는 보장은 없지만, 클라이언트가 하지 않은 자원 회수를 늦게라도 해주는 것이 아예 안하는 것보다는 나음
2. 네이티브 피어와 연결된 객체에서 사용
    - 네이티브 피어는 자바 객체가 아니기 때문에 가비지 컬렉터가 알지 못하고, 이 객체를 회수하지 못함 → cleaner나 finalizer가 나서서 처리하기 적당한 작업
    - 네이티브 피어 : 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체

<br>
<br>


## item 9 try-finally보다는 try-with-resources를 사용하라

- try-finally는 try블록과 finally블록 모두에서 발생할 수 있는데, try와 finally 모두에서 예외가 발생하면 finally에서 발생한 예외가 try블록에서 발생한 예외를 집어삼켜 스택 추적 내역에 try 블록에서 발생한 예외에 관한 정보가 남지 않음 → 실제 시스템에서의 디버깅을 몹시 어렵게 함
- try-with-resources는 try-finally의 문제를 해결
    - try문 이후와 close() 호출 양쪽에서 예외가 발생하면 close 에서 발생한 예외는 숨겨지고 try문 이후에 발생한 예외가 기록
    - 숨겨진 예외들은 버려지지 않고, 스택 추적 내역에 숨겨졌다는 꼬리표를 달고 출력됨

### 핵심 정리

- 꼭 회수해야 하는 자원을 다룰 때는 try-finally 말고, try-with-resources를 사용하자
- 코드는 더 짧고, 분명해지고, 만들어지는 예외 정보도 훨씬 유용하다.