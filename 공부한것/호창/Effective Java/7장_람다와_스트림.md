## item 42 익명 클래스보다는 람다를 사용하라

익명 클래스 방식은 코드가 너무 길기 때문에 함수형 프로그래밍에 적합하지 않음

대신, 람다를 사용하면 코드가 어떤 동작을 하는지가 명확하게 드러나게 됨

**예시**

```java
// 익명 클래스
Collections.sort(words, new Comparator<String>(){
	public int compare(String s1, String s2){
		return Integer.compare(s1.length(), s2.length());
	}
});

// 람다
Collections.sort(words, (s1,s2) -> Integer.compare(s1.length(), s2.length()));
```

람다를 언어 차원에서 지원하면서 기존에는 적합하지 않았던 곳에서도 함수 객체를 실용적으로 사용할 수 있게 됨

- item 34의 Operation 열거 타입 예)
    - apply 메서드를 상수마다 재정의한 것을 람다를 이용해 쉽게 구현할 수 있음
    - 기존 코드
        
        ```java
        public enum Operation{
        	PLUS("+"){ public double apply(double x, double y){return x+y;}}
        	MINUS("-"){ public double apply(double x, double y){return x-y;}}
        
        	private final String symbol;
        
        	Operation(String symbol){this.symbol = symbol;}
        	
        	public abstract double apply(double x, double y);
        }
        ```
        
    - 람다를 이용한 코드
        
        ```java
        public enum Operation{
        	PLUS("+", (x,y)-> x+y);
        	MINUS("-", (x,y)-> x-y);
        	
        	private final String symbol;
        	private final DoubleBinaryOperator op;
        
        	Operation(String symbol, DoubleBinaryOperator op){
        		this.symbol = symbol;
        		this.op= op;
        	}
        
        	public double apply(double x, double y){
        		erturn op.applyAsDouble(x, y);
        	}
        }
        ```
        
        **람다는 이름이 없고 문서화도 못한다.**
        
        **따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.**
        
        (람다는 한 줄일 때 가장 좋고 길어야 세 줄 안에 끝내는 게 좋다, 3줄을 넘어가면 가독성이 심하게 나빠진다.)
        
        람다가 사용되면서 익명 클래스가 사용되는 경우가 적어졌다.
        
        **하지만 람다를 사용하지 못하고 익명클래스를 사용해야 하는 경우도 존재한다**
        
        - 추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니, 익명 클래스를 써야 한다.
        - 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명클래스를 써야 한다.
        - 람다는 자신을 참조할 수 없으니 자신을 참조하기 위해서는 익명 클래스를 써야 한다.
            
            (자기 자신을 참조해야 한다면 람다 대신 익명 클래스를 써야 함)
            
            - 람다에서의 this 키워드는 바깥 인스턴스를 가리킨다.
            - 익명 클래스에서의 this 키워드는 익명 클래스 자기 자신을 가리킨다.
        
    

### 핵심정리

- 익명 클래스는(함수형 인터페이스가 아닌) 타입의 인스턴스를 만들 때만 사용하라

<br><br><br><br>

## item 43 람다보다는 메서드 참조를 사용하라

- 메서드 참조를 사용하면 람다보다 더 간결하게 코드를 작성할 수 있다.
- 매개변수 수가 늘어날수록 메서드 참조로 제거할 수 있는 양이 늘어나 더 간단해질 수 있다.
    
    하지만, 어떤 람다에서는 매개변수의 이름 자체가 프로그래머에게 좋은 가이드가 되기도 한다
    
    - 이런 람다는 길이가 더 길지만 메서드 참조보다 읽기 쉽고 유지보수도 쉬울 수 있다
    
    ```java
    service.execute(GoshThisClassNameIsHumonogous::action);
    
    service.execute(() -> action));
    ```
    

### 핵심정리

- 메서드 참조는 람다의 간단명료한 대안이 될 수 있다.
- **메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않을 때만 람다를 사용하라**

<br><br><br><br>

## item 44 표준 함수형 인터페이스를 사용하라

- java.util.function 패키지에 다양한 용도의 표준 함수형 인터페이스가 담겨 있다.
    
    필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라
    
- 대표적인 표준 함수형 인터페이스 종류
    - Operator 인터페이스 → 반환값과 인수의 타입이 같은 함수를 뜻함
        - `UnaryOperator<T> T apply(T t)` → 인수가 1개
        - `BinaryOperator<T> T apply(T t1, T t2)` → 인수가 2개
    - Predicate  인터페이스 → 인수 하나를 받아 boolean을 반환하는 함수
        - `Predicate<T> boolean test(T t)`
    - Supplier 인터페이스 : 인수를 받지 않고 값을 반환하는 함수
        - `Supplier<T> T get()`
    - Consumer 인터페이스 : 인수를 하나 받고 반환값이 없는(특히 인수를 소비하는) 함수
        - `Consumer<T> void accept(T t)`

**표준 함수형 인터페이스가 아닌 코드를 직접 작성해야 하는 경우는?**

- 자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다.
- 반드시 따라야 하는 규약이 있다.
- 유용한 디폴트 메서드를 제공할 수 있다.

**@FunctionalInterface 사용 목적**

1. 해당 클래스의 코드나 설명 문를 읽을 이에게 그 인터페이스가 람다용으로 설계된 것임을 알려주기 위해
2. 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
3. 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아줌

### 핵심정리

- 보통은 java.util.function 패키지의 표준 함수형 인터페이스를 사용하는 것이 가장 좋은 선택이다.
- 흔치는 않지만 직접 새로운 함수형 인터페이스를 만들어 쓰는 편이 나을 수 있다.

<br><br><br><br>

## item 45 스트림은 주의해서 사용하라

스트림 API는 다량의 데이터 처리 작업(순차적이든 병렬적이든)을 돕고자 자바 8에 추가됨

### 스트림 API가 제공하는 핵심 2가지

- 스트림 : 데이터 원소의 유한 혹은 무한 시퀀스
- 스트림 파이프라인
    - 스트림으로 수행하는 연산 단계를 표현하는 개념
    - 소스 스트림에서 시작해 종단 연산으로 끝나고, 그 사이에 하나 이상의 중간 연산이 존재할 수 있음
    - 지연 평가(lazy evaluation)된다
        - 평가는 종단 연산이 호출될 때 이루어지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않음
        - 종단 연산이 없는 스트림 파이프라인은 아무일도 하지 않는 것과 같아짐

### 스트림을 언제 써야 하는가?

- 스트림을 사용하여 리팩토링했을 때 리팩토링한 코드가 더 가독성이 높고 나아 보일때 사용하자


<br><br><br><br>

## item 46 스트림에서는 부작용 없는 함수를 사용하라
### 스트림 패러다임의 핵심

- 계산을 일련의 변환으로 재구성 하는 부분
- 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수 함수여야 함
    - 순수 함수
        - 오직 입력만이 결과에 영향을 주는 함수
        - 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않음

→ 스트림 연산에 건네는 함수 객체는 모두 부작용이 없어야 함

<br>

**forEach연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산할 때는 쓰지 말자**

<br><Br>

### 핵심 정리

- 스트림 파이프라인 프로그래밍의 핵심은 부작용 없는 함수 객체
    - 스트림뿐 아니라 스트림 관련 객체에 건네지는 모든 함수 객체가 부작용(side effect)이 없어야 함.
- forEach는 스트림이 수행한 계산 결과를 보고할 때만 이용해야 하고 계산 자체에는 이용하지 말자
- 스트림을 올바르게 사용하기 위해서는 수집기를 잘 알야야 함
    - 중요한 수집기 팩토리는 toList, toSet, toMap, groupingBy, joining이다.

<br><br><br><br>

## item 47 반환 타입으로는 스트림보다 컬렉션이 낫다.

**스트림은 반복을 지원하지 않음 → API를 스트림만 반환하도록 하면 반환된 스트림을 for-each로 반복하는 게 불가능**
**Collection 인터페이스 → Iterable의 하위 타입 && stream 메서드도 제공하여 반복과 스트림을 동시에 제공 → 스트림보다는 컬렉션을 반환 타입으로 사용**

**스트림은 반복을 왜 지원 안하는가?**

- Stream 인터페이스는 Iterable 인터페이스가 정의한 추상 메서드를 모두 포함하고, Iterable 인터페이스가 정의한 방식대로 동작함
- **but, Stream이 Iterable을 확장하지 않았기 때문에 for-each로 반복이 불가능함**

<br><Br>

### 핵심정리

- 원소 시퀀스를 반환하는 메서드를 작성할 때, 이를 스트림으로 처리하기 원하는 사용자와 반복으로 처리하길 원하는 사용자가 모두 있을 수 있음을 생각하자
- 컬렉션을 반환할 수 있다면 컬렉션을 반환하고, 컬렉션을 반환하지 못한다면 스트림과 Iterable 중 더 자연스러운 것을 반환하자
- 나중에 Stream 인터페이스가 Iterable을 지원하도록 자바가 수정되면, 그때는 안심하고 스트림을 반환하면 될 것이다.(스트림 처리와 반복 모두에 사용 가능하니까)

<br><br><br><br>

## item 48 스트림 병렬화는 주의해서 적용하라

**데이터 소스가 Stream.iterate 이거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로 성능 개선을 기대할 수 없음**

- 파이프라인 병렬화는 limit를 다룰 때 CPU 코어가 남는다면 원소를 몇 개 더 처리한 후 제한된 개수 이후의 결과를 버려도 아무런 해가 없다고 가정함

<br>

**스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long범위일 때 병렬화의 효과가 가장 좋다.**

- 위 자료 구조들은
    - 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어 일을 다수의 스레드에 분배하기 좋다는 특징
    - 원소들을 순차적으로 실행할 때 참조 지역성이 뛰어남
        - 참조 지역성이 낮으면 스레드는 데이터가 주 메모리에서 캐시 메모리로 전송되는 시간이 오래 걸림
        - 참조 지역성이 뛰어난 자료구조는 기본 타입의 배열 → 기본 타입 배열에서는 (참조가 아닌)데이터 자체가 메모리에 연속해서 저장되기 때문

<br>

**스트림 파이프라인 종단 연산의 동작 방식은 병렬 수행 효율에 영향을 줌**

- **병렬화에 가장 적합한 종단 연산은 축소(reduction)**
    - 축소는 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업, reduce 메서드나 min, max, count, sum중 선택해 실행
- **anyMatch, allMatch, noneMatch처럼 조건에 맞으면 바로 반환되는 메서드도 병렬화에 적합**

<br>

**가변 축소를 수행하는 Stream의 Collect 메서드는 병렬화에 적합하지 않음**

- 컬렉션들을 합치는 부담이 크기 때문

<br>

스트림 병렬화를 통해 실제 성능이 향상될지 추정하는 방법

- 스트림 안의 원소 수와 원소당 수행되는 코드 줄 수의 곱이 최소 수십만은 되어야 성능 향상을 볼 수 있음

<br><br>

### 핵심정리

- 계산도 올바로 수행하고 성능도 빨라질 거라는 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지 말라
- 스트림을 잘못 병렬화하면 프로그램을 오작동하게 하거나 성능을 급격히 떨어뜨린다.

