## item 49 매개변수가 유효한지 검사하라

메서드 바디가 실행되기 전에 매개변수를 확인하면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있음

<br>

### **매개변수 검사를 제대로 하지 못할 때 발생하는 문제들**

1. 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
2. 메서드가 잘 수행되지만 잘못된 결과를 반환할 수 있다.
3. 메서드가 문제업시 수행되었지만, 어떤 객체를 이상한 상태로 만들어서 미래의 알수 없는 시점에 이 메서드와는 관련없는 오류를 낼 수 있다.
- **즉, 매개변수 검사에 실패하면 실패 원자성을 어기는 결과를 낳을 수 있음**

### Objects.requireNonNull() 메서드

- null 검사를 자동으로 해주는 메서드
- 원하는 예외 메시지를 지정할 수 있고, 입력을 그대로 반환하여 값을 사용하는 동시에 null 검사를 수행할 수 있음
- 반환 값을 무시하고 순수한 null 검사 목적으로 사용해도 됨.

```java
this.strategy = Objects.requireNonNull(strategy, "전략");
```

### 공개되지 않은 메서드라면?

- 패키지 제작자가 메서드가 호출되는 상황을 통제할 수 있음
- 따라서 오직 유효한 값만이 메서드에 넘겨지리라는 것을 보증할 수 있고, 그렇게 해야 함
- 다시 말해 public 이 아닌 메서드라면 단언문을 사용해 매개변수 유효성을 검증할 수 있다.

### 생성자는 매개변수 유효성 검사는 해야 할까?

- **생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 꼭 필요하다.**

<br>

### 핵심정리

- 메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있울지 생각해야 함
- 그 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야 함.

<br><br>

## item 50 적시에 방어적 복사본을 만들라

어떤 객체든 그 객체의 허락 없이는 외부에서 내부를 수정하는 일은 불가능하다.
하지만 주의를 기울이지 않으면 내부를 수정하도록 허락하는 경우가 생긴다.
**따라서 외부 공격으로부터 인스턴스 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다.**

<br>

### 매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고 이 복사본으로 유효성을 검증해야 하는 이유?

- 멀티스레딩 환경에서 원본 객체의 유효성을 검사한 후 복사본을 만들면 그 순간 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다.
- 방어적 복사를 매개변수 유효성 검사 이전에 수행하면 이런 위험에서 해방될 수 있음

**매개변수를 방어적으로 복사하는 목적이 불변 객체를 만들기 위해서만은 아님**

- 가변 객체라면 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제없이 동작할지를 따져보기 위해
- 확신할 수 없으면 복사본을 만들어 저장해야 함
- 예컨데 클라이언트가 건네준 객체를 내부의 Set 인스턴스에 저장하거나 Map 인스턴스 키로 사용하면 추후 그 객체가 변경될 경우 객체를 담고 있는 Set 혹은 Map의 불변식이 깨질 것이다.
    - 따라서 이런 경우는 복사본을 만드는 것이 좋다.

<br>

### 핵심 정리

- 클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.
- 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때 책임이 클라이언트에 있음을 문서로 명시하도록 하자.
