## item 49 매개변수가 유효한지 검사하라

메서드 바디가 실행되기 전에 매개변수를 확인하면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있음

<br>

### **매개변수 검사를 제대로 하지 못할 때 발생하는 문제들**

1. 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
2. 메서드가 잘 수행되지만 잘못된 결과를 반환할 수 있다.
3. 메서드가 문제업시 수행되었지만, 어떤 객체를 이상한 상태로 만들어서 미래의 알수 없는 시점에 이 메서드와는 관련없는 오류를 낼 수 있다.
- **즉, 매개변수 검사에 실패하면 실패 원자성을 어기는 결과를 낳을 수 있음**

### Objects.requireNonNull() 메서드

- null 검사를 자동으로 해주는 메서드
- 원하는 예외 메시지를 지정할 수 있고, 입력을 그대로 반환하여 값을 사용하는 동시에 null 검사를 수행할 수 있음
- 반환 값을 무시하고 순수한 null 검사 목적으로 사용해도 됨.

```java
this.strategy = Objects.requireNonNull(strategy, "전략");
```

### 공개되지 않은 메서드라면?

- 패키지 제작자가 메서드가 호출되는 상황을 통제할 수 있음
- 따라서 오직 유효한 값만이 메서드에 넘겨지리라는 것을 보증할 수 있고, 그렇게 해야 함
- 다시 말해 public 이 아닌 메서드라면 단언문을 사용해 매개변수 유효성을 검증할 수 있다.

### 생성자는 매개변수 유효성 검사는 해야 할까?

- **생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 꼭 필요하다.**

<br>

### 핵심정리

- 메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있울지 생각해야 함
- 그 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야 함.

<br><br>

## item 50 적시에 방어적 복사본을 만들라

어떤 객체든 그 객체의 허락 없이는 외부에서 내부를 수정하는 일은 불가능하다.
하지만 주의를 기울이지 않으면 내부를 수정하도록 허락하는 경우가 생긴다.
**따라서 외부 공격으로부터 인스턴스 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다.**

<br>

### 매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고 이 복사본으로 유효성을 검증해야 하는 이유?

- 멀티스레딩 환경에서 원본 객체의 유효성을 검사한 후 복사본을 만들면 그 순간 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다.
- 방어적 복사를 매개변수 유효성 검사 이전에 수행하면 이런 위험에서 해방될 수 있음

**매개변수를 방어적으로 복사하는 목적이 불변 객체를 만들기 위해서만은 아님**

- 가변 객체라면 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제없이 동작할지를 따져보기 위해
- 확신할 수 없으면 복사본을 만들어 저장해야 함
- 예컨데 클라이언트가 건네준 객체를 내부의 Set 인스턴스에 저장하거나 Map 인스턴스 키로 사용하면 추후 그 객체가 변경될 경우 객체를 담고 있는 Set 혹은 Map의 불변식이 깨질 것이다.
    - 따라서 이런 경우는 복사본을 만드는 것이 좋다.

<br>

### 핵심 정리

- 클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.
- 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때 책임이 클라이언트에 있음을 문서로 명시하도록 하자.

<br><br><br>


## item 51 메서드 시그니처를 신중히 설계하라

개별 아이템으로 두기 애매한 API 설계 요령들을 모아 놓음
- **메서드 이름을 신중히 짓자**
- **편의 메서드를 너무 많이 만들지 말자**
- **매개변수 목록을 짧게 유지하라**

<br>

### **메서드 이름을 신중하게 짓자**
- 표준 명명 규칙(item 68)을 따라야 함
- 이해할 수 있고, 같은 패키지에 속한 다른 이름들과 일관되게 짓는 것이 최우선
- 개발자 커뮤니티에서 널리 받아들여지는 이름 사용

<br>

### **편의 메서드를 너무 많이 만들지 말자**
- 메서드가 너무 많은 클래스(인터페이스)는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어려움

<br>

### **매개변수 목록을 짧게 유지하라**
- 4개 이하가 좋고, 4개가 넘어가면 매개변수를 전부 기억하기 어려움

<br>

### 과하게 긴 매개변수 목록을 짧게 줄여주는 기술 3가지

1. **여러 메서드로 쪼갠다.**
    - 쪼개진 메서드 각각은 원래 매개변수 목록의 부분 집합을 받고 조합하여 해결
    - 예)
        - java.util.List가 좋은 예 → 지정된 범위의 부분 리스트에서 주어진 원소의 인덱스를 찾는 기능을 하나의 메서드로 구현할 때 → (부분리스트 시작, 끝, 찾을 원소 ) 3가지가 매개변수로 필요
            - 부분 리스트를 반환하는 메서드 + 주어진 원소의 인덱스를 찾는 메서드 → 두 메서드를 조합하여 위의 목적을 이룰 수 있음(각 메서드의 매개변수 개수를 줄임)
2. **매개변수 여러 개를 묶어주는 도우미 클래스를 만든다**
    - 보통 정적 멤버 클래스로 둠
    - 특히 잇따른 매개변수 몇 개를 독립된 하나의 개념으로 볼 수 있을 때 추천하는 기법
    - 예)
        - card 게임에서 카드의 숫자(rank)와 무늬(suit)를 뜻하는 매개변수를 하나의 클래스로 묶는 도우미 클래스를 만들어 하나의 매개변수만 전달할 수 있음
3. **앞의 두 기법을 혼합, 객체 생성에 사용한 빌더 패턴을 메서드 호출에 응용**
    - 메서드에 파라미터로 전달할 모든 매개변수를 포함한 하나의 추상화한 객체를 정의하고, 클라이언트에서 이 객체의 setter를 이용해 필요한 값을 설정
    - 이후 설정이 완료된 객체를 매개변수로 넘겨 처리

<br>
<br>
<br>
<br>

## item 52 메서드 시그니처를 신중히 설계하라

```java
public class CollectionClassifier{
	public static String classify(Set<?> s){
		return "집합";
	}
	public static String classify(List<?> s){
		return "리스트";
	}
	public static String classify(Collection<?> s){
		return "그 외";
	}

	public static void main(String[] args){
		Collection<?>[] collections = {
			new HashMap<String>(),
			new ArrayList<BigInteger>(),
			new HashMap<String,String>().values()
		};
		for(Collection<?> c : collections){
			System.out.println(classify(c));
		}
	}
}
```

위코드는 “집합”, “리스트”, “그 외”를 차례로 출력하지 않고 실제 수행하면 “그 외” 가 3번 연속 나오는 이유?
- **다중정의된 세 classify 중 어느 메서드를 호출할지가 컴파일시점에 정해지기 때문**
- 컴파일 타임에 for문 안의 c는 항상 Collection<?> 타입이기 때문

<br>

**재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택된다는 것이 중요**
→ 다중 정의된 메서드 사이에는 객체의 런타임 타입은 전혀 중요치 않고 오직 매개변수의 컴파일타임 타입에 의해 이루어짐

<br>

**안정적이고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자**

<br>

매개변수 수가 같은 다중 정의 메서드가 많아도, 그중 어느 것도 주어진 매개변수 집합을 처리할지가 명확히 구분된다면 헷갈릴 일은 없음

- 매개변수 중 하나 이상이 “근본적으로 다르다”면 헷갈릴 일이 없음
- 근본적으로 다르다 → 두 타입의(null이 아닌) 값을 서로 어느 쪽으로든 형변환할 수 없다는 뜻이다.
- 이 조건만 충족하면 어느 다중정의 메서드를 호출할지가 매개변수들의 런타임 타입만으로 결정된다.
<br>

### 핵심 정리

- 일반적으로 매개변수 수가 같을 때는 다중정의를 피하는게 좋다.
- 상황에 따라, 특히 생성자라면 이 조언을 따르기 불가능할 수도 있다.
    - 그럴 때는 헷갈릴 만한 매개변수는 형변환하여 정확한 다중정의 메서드가 선택되도록 해야 함

<br>
<br>
<br>
<br>

## item 53 가변인수는 신중히 사용하라

### **가변 인수 메서드**
- 명시한 타입의 인수를 0개 이상 받을 수 있음
- 가변인수 메서드를 호출하면, 가장 먼저 인수의 개수와 길이가 같은 배열을 생성하고 인수들을 이 배열에 저장하여 가변 인수 메서드에 건네줌

<br>

### 인수가 1개 이상이어야 하는 가변인수 메서드
**잘못 구현한 예**

- 문제는 인수를 0개만 넣어 호출하면 (컴파일타임이 아닌) 런타임에 실패한다는 점
    
    ```java
    static int min(int... args){
    	if(args.length==0) throw new IllegalArgumentException("인수가 1개 이상 필요합니다");
    	int min = args[0];
    	for(int i = 1; i<args.length; i++){
    		if(args[i]<min) min = args[i];
    	}
    	return min;
    }
    ```
<br>
    

**제대로 구현한 예**
- 위 코드처럼 매개변수를 2개 받도록 하여 런타임에 실패하는 문제를 해결할 수 있음
    - 첫번째는 평범한 매개변수를 받고, 가변인수는 두 번째로 받으면 앞서의 문제가 말끔히 사라진다.
    
    ```java
    static int min(int firstArg, int... remainingArgs){
    	int min =firstArg;
    	for(int arg: remainingArgs){
    		if(arg<min){
    			min = arg;
    		}
    	}
    	return min;
    }
    ```

**성능에 민감한 상황이라면 가변 인수가 걸림돌이 될 수 있음 → 가변인수 메서드는 호출될 때마다 배열을 새로 하나 할당하고 초기화하기 때문**

- 해결 방법
    - 인수가 여러개인 다중 정의 메서드를 만들어놓는 것

<br>

### 핵심정리

- 인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수가 반드시 필요하다.
- 메서드를 정의할 때 필수 매개변수는 가변인수 앞에 두고, 가변인수를 사용할 때는 성능 문제까지 고려하자.

<br>
<br>
<br>
<br>

## item 54 null이 아닌, 빈 컬렉션이나 배열을 반환하라

**컬렉션이나 배열 같은 컨테이너가 비었을 때 null을 반환하는 메서드를 사용하면 아래와 같은 방어 코드를 넣어야 한다.**
```java
List<Cheese> cheeses. =shop.getCheeses();
if(cheeses != null){ ... }
```
**따라서 null이 아닌, 빈 컬렉션이나 배열을 반환하자**

<br>

### 때로는 빈 컨테이너를 할당하는 데도 비용이 드니 null을 반환하는 것이 낫다는 주장의 틀린 점

1. 성능 분석 결과 이 할당이 성능 저하의 주범이라고 확인되지 않는 한 이 정도의 성능 차이는 신경 쓸 수준이 못된다.
2. 빈 컬렉션과 배열은 굳이 새로 할당하지 않고도 반환할 수 있다.
    - 예시)
        
        ```java
        public List<Cheese> getCheeses(){
        	return cheesesInStock.isEmpty() ? Collections.emptyList() : new ArrayList<>(cheesesInStock);
        }
        ```
        
        - `Collections.emptyList()`
            - 매번 동일한 빈 불변 컬렉션을 반환
<br>

### 핵심 정리

- null이 아닌, 빈 배열이나 컬렉션을 반환하라.
- null을 반환하는 API는 사용하기 어렵고 오류 처리 코드도 늘어난다. 그렇다고 성능이 좋은 것도 아니다.

<br>
<br>
<br>
<br>

## item 55 옵셔널 반환은 신중히 하라
- 옵셔널을 사용하면 유효한 반환값이 없을 때 빈 결과를 반환한다.
- 옵셔널을 반환하는 메서드는 예외를 던지는 메서드보다 유연하고 사용하기 쉬우며, null을 반환하는 메서드보다 오류 가능성이 작다.

<br>

### 언제 메소드의 리턴 값으로 Optional을 리턴해야 하는가?
- 결과가 없을 수 있으며, 클라이언트가 이 상황을 특별하게 처리해야 한다면 Optional<T>를 반환한다.

<br>

### 박싱된 기본 타입을 담는 Optional은?
- 값을 두번 감싸기 때문에 기본 타입 자체보다 무겁다 → 자바 API 설계자가 int, long, double 전용 Optional 클래스들을 사용하면 됨(`OptionalInt, OptionalLong, OptionalDouble`)

### Optional을 사용하면 안되는 경우
- **컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안됨**
    - 빈 컨테이너를 옵셔널로 감싸지 않으면 클라이언트에서 Optional 처리 코드를 넣지 않아도 됨
- **Optional을 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는 게 적절한 상황은 거의 없음**
    - Map의 key에 Optional을 사용하면 안됨
        - Map 안에 키가 없다는 사실을 나타내는 방법이 2가지가 되어버리기 때문이다.
            - 2가지 방법
                1. 키 자체가 없는 경우
                2. 키는 존재하지만 그 키가 속이 빈 Optional(Optional.empty())인 경우
<br>

### 핵심 정리
- 값을 반환하지 못할 가능성이 있고, 호출할 때마다 반환값이 없을 가능성을 염두에 둬야 하는 메서드라면 옵셔널을 반환해야 하는 상황일 수 있다.
- 하지만, 옵셔널 반환에는 성능 저하가 뒤따름 → 성능에 민감한 메서드라면 null을 반환하거나 예외를 던지는 편이 나을 수 있음
- Optional이 반환값 이외의 용도로 쓰는 경우는 매우 드물다.
