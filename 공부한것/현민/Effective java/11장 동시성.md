# 동시성

## 78. 공유 중인 가변 데이터는 동기화해 사용하라

synchronized 키워드는 해당 메소드나 블록을 한번에 한 쓰레드씩 수행하도록 보장한다.

많은 프로그래머가 동기화를 **배타적 실행**, 즉 한 쓰레드가 변경하는 중이라서 상태가 일관되지 않은 순간의 객체를 다른 쓰레드가 보지 못하게 막는 용도로만 생각한다.

<br>

동기화에는 중요한 기능이 하나 더 있다. 동기화 없이는 한 쓰레드가 만든 변화를 다른 쓰레드에서 확인하지 못할 수 있다.

동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론, 동기화된 메소드나 블록에 들어간 쓰레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다.

<br>

언어 명세상 long과 double 외의 변수를 읽고 쓰는 동작은 원자적이다.

여러 쓰레드가 같은 변수를 동기화 없이 수정하는 중이라도, 항상 어떤 쓰레드가 정상적으로 저장한 값을 읽어옴을 보장한다는 뜻이다.

자바 언어 명세는 쓰레드가 필드를 읽을 때 항상 ‘수정이 완전히 반영된’ 값을 얻는다고 보장하지만, 한 쓰레드가 저장한 값이 다른 쓰레드에게 ‘보이는가’는 보장하지 않는다.

**동기화는 배타적 실행뿐 아니라 쓰레드 사이의 안정적인 통신에 꼭 필요하다.**

<br>

쓰기와 읽기 모두가 동기화되지 않으면 동작을 보장하지 않는다.

volatile 한정자는 배타적 수행과는 상관없지만 항상 가장 최근에 기록된 값을 읽게 됨을 보장한다.

java.util.concurrent.atomic 패키지에는 락 없이도 쓰레드 안전한 프로그래밍을 지원하는 클래스들이 담겨 있다. volatile은 동기화의 두 효과 중 통신 쪽만 지원하지만 이 패키지는 원자성(배타적 실행)까지 지원한다.

<br>

**정리**

여러 쓰레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화 해야 한다.

동기화하지 않으면 한 쓰레드가 수행한 변경을 다른 쓰레드가 보지 못할 수도 있다.

배타적 실행은 필요 없고 쓰레드끼리의 통신만 필요하다면 volatile 한정자만으로 동기화할 수 있다. 다만 올바로 사용하기가 까다롭다.

## 79. 과도한 동기화는 피하라

과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.

<br>

응답 불가와 안전 실패를 피하려면 동기화 메소드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.

- 동기화된 영역 안에서는 재정의할 수 있는 메소드는 호출하면 안 되며, 클라이언트가 넘겨준 함수 객체를 호출해서도 안 된다.

기본 규칙은 동기화 영역에서는 가능한 한 일을 적게 하는 것이다. 락을 얻고, 공유 데이터를 검사하고, 필요하면 수정하고, 락을 놓는다.

<br>

과도한 동기화가 초래하는 진짜 비용은 락을 얻는 데 드는 CPU 시간이 아니다. 경쟁하느라 낭비하는 시간, 즉 병렬로 실행할 기회를 잃고, 모든 코어가 메모리를 일관되게 보기 위한 지연시간이 진짜 비용이다.

가변 클래스를 작성하려거든 다음 두 선택지 중 하나를 따르자.

1. 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자.
2. 동기화를 내부에서 수행해 쓰레드 안전한 클래스로 만들자.
  - 단, 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 두 번째 방법을 선택해야 한다.

## 80. 쓰레드보다는 실행자, 테스크, 스트림을 애용하라

java.util.concurrent 패키지에는 실행자 프레임워크(Executor Framework)라고 하는 인터페이스 기반의 유연한 테스크 실행 기능을 담고 있다.

작업 큐를 다음의 단 한 줄로 생성할 수 있다.

`ExecutorService exec = Executors.newSingleThreadExecutor();`

이 실행자에 실행할 테스크를 넘기는 방법은 다음과 같다.

`exec.execute(runnable);`

실행자 서비스의 기능은 이 외에도 많다. 주요 기능들은 아래와 같다.

- 특정 테스크가 완료되기를 기다린다.
- 테스크 모음 중 아무것 하나 혹은 모든 테스크가 완료되기를 기다린다.
- 실행자 서비스가 종료하기를 기다린다.
- 완료된 테스크들의 결과를 차례로 받는다.
- 테스크를 특정 시간에 혹은 주기적으로 실행하게 한다.

<br>

큐를 둘 이상의 쓰레드가 처리하게 하고 싶다면 간단히 다른 정적 팩토리를 이용하여 다른 종류의 실행자 서비스(쓰레드 풀)을 생성하면 된다.

작업 큐를 손수 만드는 일은 삼가야 하고, 쓰레드를 직접 다루는 것도 일반적으로 삼가야 한다.

쓰레드를 직접 다루면 Thread가 작업 단위와 수행 메커니즘 역할을 모두 수행하게 된다.

반면 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리된다. 작업 단위를 나타내는 핵심 추상 개념이 테스크다.

테스크에서는 두 가지가 있다. Runnable과 Callable(Runnable과 비슷하지만 값을 반환하고 임의의 예외를 던질 수 있다)

핵심은 실행자 프레임워크가 작업 수행을 담당해준다는 것이다.

<br>

자바7에서 실행자 프레임워크는 fork-join 테스크를 지원하도록 확장되었다.

fork-join 테스크의 인스턴스는 작은 하위 테스크로 나뉠 수 있고, ForkJoinPool을 구성하는 쓰레드들이 이 태스크들을 처리하며, 일을 먼저 끝낸 쓰레드는 다른 쓰레드의 남은 테스크를 가져와 대신 처리할 수도 있다.

## 81. wait와 notify보다는 동시성 유틸리티를 애용하라

wait와 notify는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하자.

<br>

java.util.concurrent의 고수준 유틸리티는 세 범주로 나눌 수 있다.

- 실행자 프레임워크, 동시성 컬렉션, 동기화 장치

<br>

동시성 컬렉션은 List, Queue, Map 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션이다.

높은 동시성에 도달하기 위해 동기화를 각자의 내부에서 수행한다. 따라서 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하며, 외부에서 락을 추가로 사용하면 오히려 속도가 느려진다.

동시성 컬렉션에서 동시성을 무력화하지 못하므로 여러 메소드를 원자적으로 묶어 호출하는 일 역시 불가능하다. 따라서 여러 기본 동작을 하나의 원자적 동작으로 묶는 ‘상태 의존적 수정’ 메소드들이 추가되었다.

<br>

동기화 장치는 쓰레드가 다른 쓰레드를 기다릴 수 있게 하여, 서로 작업을 조율할 수 있게 해준다.

가장 자주 쓰이는 동기화 장치는 CountDownLatch와 Semaphore다. 그리고 가장 강력한 동기화 장치는 Phaser다.

CountDownLatch는 일회성 장벽으로, 하나 이상의 쓰레드가 또다른 하나 이상의 쓰레드 작업이 끝날 때까지 기다리게 한다.

## 82. 쓰레드 안전성 수준을 문서화하라

멀티쓰레드 환경에서도 API를 안전하게 사용하게 하려면 클래스가 지원하는 쓰레드 안전성 수준을 정확히 명시해야 한다.

다음 목록은 쓰레드 안전성이 높은 순으로 나열한 것이다.

- 불변(immutable)
  - 이 클래스의 인스턴스는 마치 상수와 같아서 외부 동기화도 필요 없다.
  - ex) String, Long, BigInteger
- 무조건적 쓰레드 안전(unconditionally thread-safe)
  - 이 클래스의 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 별도의 외부 동기화없이 동시에 사용해도 안전하다.
  - ex) AtomicLong, ConcurrentHashMap
- 조건부 쓰레드 안전(conditionally thread-safe)
  - 무조건적 쓰레드 안전과 같으나, 일부 메소드는 동시에 사용하려면 외부 동기화가 필요하다.
  - ex) Collections.synchronized 래퍼 메소드가 반환한 컬렉션들이 여기 속한다.
- 쓰레드 안전하지 않음(not thread-safe)
  - 이 클래스의 인스턴스는 수정될 수 있다. 동시에 사용하려면 각각의 메소드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야 한다.
  - ex) ArrayList, HashMap 같은 기본 컬렉션
- 쓰레드 적대적(thread-hostile)
  - 이 클래스는 모든 메소드 호출을 외부 동기화로 감싸더라도 멀티쓰레드 환경에서 안전하지 않다.
  - 이런 수준의 클래스는 일반적으로 정적 데이터를 아무 동기화 없이 수정한다. 동시성을 고려하지 않고 작성하다 보면 우연히 만들어질 수 있다.

<br>

조건부 쓰레드 안전한 클래스는 주의해서 문서화해야 한다.

어떤 순서로 호출할 때 외부 동기화가 필요한지, 그리고 그 순서로 호출하려면 어떤 락 혹은 락들을 얻어야 하는지 알려줘야 한다.

<br>

**정리**

모든 클래스가 자신의 쓰레드 안전성 정보를 명확히 문서화해야 한다.

정확한 언어로 명확히 설명하거나 쓰레드 안전성 어노테이션을 사용할 수 있다. synchronized 한정자는 문서화와 관련이 없다.

무조건적 쓰레드 안전 클래스를 작성할 때는 synchronized 메소드가 아닌 비공개 락 객체를 사용하자. 이렇게 해야 클라이언트나 하위 클래스에서 동기화 메커니즘을 깨뜨리는 걸 예방할 수 있다.

## 83. 지연 초기화는 신중히 사용하라

지연 초기화(lazy initialization)는 필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법이다. 그래서 값이 전혀 쓰이지 않으면 초기화도 결코 일어나지 않는다.

지연 초기화는 주로 최적화 용도로 쓰이지만, 클래스와 인스턴스 초기화 때 발생하는 위험환 순환 문제를 해결하는 효과도 있다.

<br>

지연 초기화는 필요할 때까지는 하지 말자. 지연 초기화는 양날의 검이다.

클래스 혹은 인스턴스 생성의 초기화 비용은 줄지만 그 대신 지연 초기화하는 필드에 접근하는 비용은 커진다.

그럼에도 지연 초기화가 필요할 때가 있다. 해당 클래스의 인스턴스 중 그 필드를 사용하는 인스턴스의 비율이 낮은 반면, 그 필드를 초기화하는 비용이 크다면 지연 초기화가 제 역할을 해줄 것이다.

<br>

대부분의 상황에서 일반적인 초기화가 지연 초기화보다 낫다.

지연 초기화가 초기화 순환성을 깨뜨릴 것 같으면 synchronized를 단 접근자를 사용하자.

<br>

성능 때문에 정적 필드를 지연 초기화해야 한다면 지연 초기화 홀더 클래스 관용구를 사용하자.

```java
private static class FieldHolder {
		static final FieldType field = computeFieldValue();
}
private static FieldType getField() {
		return FieldHolder.field;
}
```

getField가 처음 호출되는 순간 FieldHolder.field가 처음 읽히면서, 비로소 FieldHolder 클래스 초기화를 촉발한다.

getField 메소드가 필드에 접근하면서 동기화를 전혀 하지 않으니 성능이 느려질 거리가 전혀 없다.

<br>

성능 때문에 인스턴스 필드를 지연 초기화해야 한다면 이중검사 관용구를 사용하자.

```java
private volatile FieldType field;

private FieldType getField() {
		FieldType result = field;
		if(result != null) // 첫번째 검사(락 사용 안함)
				return result;

		synchronized(this) {
				if(field == null) // 두 번째 검사(락 사용)
						field = computeFieldValue();
				return field;
		}
}
```

이 관용구는 초기화된 필드에 접근할 때의 동기화 비용을 없애준다.

필드가 초기화 된 후로는 동기화하지 않으므로 해당 필드는 반드시 volatile로 선언해야 한다.

result 지역변수는 필드가 이미 초기화된 상황에서는 그 필드를 딱 한 번만 읽도록 보장하는 역할을 한다.

## 84. 프로그램의 동작을 쓰레드 스케줄러에 기대지 말라

여러 쓰레드가 실행 중이면 운영체제의 쓰레드 스케줄러가 어떤 쓰레드를 얼마나 오래 실행할지 정한다.

잘 작성된 프로그램이라면 이 정책에 좌지우지돼서는 안 된다.

정확성이나 성능이 쓰레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.

<br>

견고하고 빠릿하고 이식성 좋은 프로그램을 작성하는 가장 좋은 방법은 실행 가능한 쓰레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것이다.

그래야 쓰레드 스케줄러가 고민할 거리가 줄어든다.

<br>

실행 가능한 쓰레드 수를 적게 유지하는 주요 기법은 각 쓰레드가 무언가 유용한 작업을 완료한 후에는 다음 일거리가 생길 때까지 대기하도록 하는 것이다.

쓰레드는 당장 처리해야 할 작업이 없다면 실행해서는 안 된다.