### 템플릿 콜백 패턴이 무엇인가?
- 변하지 않는 일정한 패턴을 가지는 작업 흐름이 존재하고, 그 중 일부분이 자주 변할 때 적합한 구조이고 스프링에서 이를 템플릿 콜백 패턴이라 부른다.
- 또한 전략 패턴을 기반으로 콜백 오브젝트를 사용하는 구조이다.
### 템플릿 메서드 패턴과 템플릿 콜백 패턴이 다르다면 어떻게 다른가? 또한 같다면 어떤 점이 같은가?
- 같은 점
  - 작업 흐름이 변하지 않는 부분과 작업 흐름 중 자주 변하는 부분을 분리했다는 공통점이 있다.
- 다른 점
  - 템플릿 콜백 패턴은 합성을 이용해 컨텍스트와 콜백의 결합도가 낮아 유연하게 변경이 가능하지만, 템플릿 메서드 패턴은 상속을 이용해서 결합도가 높아 유연하게 변경이 되지 않는다는 차이가 있다. 
### 스프링에서 템플릿 콜백 패턴을 쓰고 있는 모듈들은 어떤 것이 존재하는가?
  - JDBC 템플릿, redis 템플릿, rest 템플릿이 있다.
### effective unit testing 1장에 대해 설명해 줄 수 있는가?
  - **테스트를 작성해야 하는 이유**와 **좋은 테스트를 작성해야 하는 이유**, **테스트의 가치**가 무엇인지, 이런 **가치들을 잘 사용하기 위해서**는 어떻게 해야 하는지를 설명하고 있다
  - 테스트를 작성해야 하는 이유는 테스트가 코드의 **품질 보증 수단**이 되기 때문이고, **좋은 테스트를 작성해야 하는 이유**는 테스트는 제품 코드를 설계하는 **설계 수단**으로서 사용되기 때문이다.
  - 테스트의 가치는 **품질 보증 수단**, **설계 수단**으로서의 가치가 있다
  - 이런 가치들을 잘 사용하기 위해서는 다음 두 가지를 실천해야 한다
    1. 테스트 코드도 제품 코드를 다루듯 해야 한다. 믿고 의지할 수 있을 만큼 철저한 리팩토링을 통해 높은 품질을 유지해야 한다
    2. 제품 코드가 목적과 쓰임새에 맞는 구조를 가질 수 있게끔 이끌어주는 설계 수단으로 활용해야 한다.
     
### 테스트할 때 happy case가 아닌 edge case에 대해 테스트하지 않으면 테스트하는 이유가 없어지는데 RIGTH BICEP은 무엇인가?
- RIGTH BICEP은 무엇을 테스트해야 하는지를 쉽게 결정할 수 있도록 도와주는 것이다
- RIGHT : 결과가 올바른가?
  - Test의 목적과 동작을 올바르게 이해하여, 정상적으로 테스트를 통과했을 때 결과가 올바른 결과인지 판단할 수 있어야 한다.
- B(Boundary conditions) : 경계 조건은 맞는가?
  - 결함은 경계 조건에서 많이 발생하기 떼문에 경계 조건을 처리해야 한다.
  - 예시로는 비거나 빠진 값(Null, "), 모호하고 일관성이 없는 입력 값(!,@,#,$ 등)이 포함된 경우, 이성적인 기대값을 벗어나는 값(200세의 나이) 등이 있다.
- I(Inverse Relationship) : 역 관계를 검사할 수 있는가?
  - 논리적인 역 관계를 적용해서 검사한다( 뺄셈을 덧셈으로 검증 등)
- C(Cross check) : 다른 검증 수단으로 교차 검증이 가능한가?
  - 제곱근을 구하는 메서드가 존재하면 Math.sqrt()뿐만 아니라 다른 수단(라이브러리)으로 제곱근을 구하는 메서드를 테스트 할 수 있어야 한다.
- E(Error Conditions) : 오류 조건을 강제로 일어나게 할 수 있는가?
  - 오류를 강제로 발생시켜 테스트를 진행한다
  - 오류에는 메모리가 가득 찬 경우, 디스크 공간이 가득 찬 경우, 네트워크 오류 등이 있다
- P(Performance Characteristics) : 성능 조건은 기준에 부합하는가?
  - 최적화 이전의 실행 결과를 기준으로 잡고, 최적화 이후의 실행 결과와 비교하여 성능 계산
### 아래 코드는 피보나치 수열에 대한 테스트 케이스를 작성하는 코드이고, 아래 코드에서 빠져 있는 경계 조건 2가지가 무엇일까?  
```java
@Test
public void fibo(){
	Fibonacci fibonacci = new Fibonacci();

	assertThat(fibonacci.fibo(1)).is(1);
	assertThat(fibonacci.fibo(2)).is(1);
	assertThat(fibonacci.fibo(3)).is(2);
	assertThat(fibonacci.fibo(4)).is(3);
	assertThat(fibonacci.fibo(5)).is(5);
}
```
  - 첫번째 경계 조건은 음수 값이다
  - 두번째 경계 조건은 int 또는 long으로 표현할 수 없는 범위의 매우 큰 값이다.