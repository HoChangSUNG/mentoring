- ### 상속을 왜 쓸까?
  - 부모 클래스의 속성을 자식 클래스에서 재사용하기 위해서 사용한다.
- ### 상속에서 부모의 상태를 계속 가져가야 하는데 그런 경우가 어떤 경우일까?
  - is-a 관계처럼 자식 클래스가 부모 클래스의 상태를 모두 가져야 하는 경우 사용한다
  - 예를 들어 개는 동물이다 처럼 개가 동물의 모든 상태를 가지고 있고 개가 동물이란 것을 구체화시키는 경우 사용한다
  - 하지만, 상속은 부모 클래스와 자식 클래스가 긴밀히 연결(높은 결합도)되어 있어 변경 사항이 존재할 경우 자식 클래스를 수정하거나 새로 작성해야 할 수도 있다.
- ### 관심사란 무엇인가?
  - 현재 다루고자 하는 특정 주제나 관심 영역을 관심사라고 한다.
- ### 초난감 DAO에서는 관심사가 무엇 무엇이 존재했는가?
  - db 생성 방법, 쿼리 실행, 의존 오브젝트 사용의 관심사가 존재한다.
- ### 관심사의 분리는 무엇인가?
  - 클래스나 모듈에 동일한 관심사를 집중시키고, 다른 관심사를 분리시켜 서로 영향을 주지 않도록 하는 것
- ### 관심사의 분리의 예시는 무엇인가?
  - 각각의 비즈니스 로직(add(),get())을 수행하는 메소드에 db 생성 방법을 결정하는 코드가 존재할 때, db 생성 방법을 메소드로 추출하여 각각의 비즈니스 로직 관련 관심사와 db 생성 방법 관심사를 분리한 것이 예시이다.
- ### 어떤 코드를 보거나 작업을 할 때 어떤 것을 관심사가 서로 다르다고 볼 수 있을까?
  - 변화의 성격이 다르면 관심사가 다르다고 볼 수 있다
  - 여기서 변화의 성격은 변화의 이유, 주기 등을 말한다
  - 예시로는 db 생성 방법과 유저 정보를 조회하거나 조작하는 UserDao가 있다. UserDao는 유저에 기능 추가나 수정과 같은 이유로 변경되지만, db 생성 방법은 사용하려는 db를 변경해야 하는 이유로 변경된다.
  
- ### ioc 컨테이너와 우리가 토비의 스프링 1장의 초난감 DAO를 리팩토링한 부분이 어떤 연관이 있는가?
  - 토비의 스프링 1장은 초난감 dao를 메소드 추출, 상속을 통한 관심사 분리, 클래스로 관심사 분리, 인터페이스를 이용한 관심사 분리, 사용과 객체 생성/연관관계 설정을 분리하는 과정을 통해 스프링이 왜 ioc 컨테이너를 사용하게 되었는지 과정을 알려주고 있다.
<br>

- ### 토비의 스프링 1장에서 초난감 DAO에서 각 단계별로 제기한 문제와 문제 해결 방법을 설명해줄 수 있는가?
  1. #### 메소드 추출
     - 사용 이유 : 메소드마다 db 생성 방법이 존재하여 db 생성 방법을 수정하면 모든 메소드마다 db 생성 방법 코드를 수정해줘야 하는 문제가 존재하기 때문
     - 해결 방법 : 메소드마다 있는 db 생성 방법을 하나의 메소드로 추출하여 db 생성 방법이 존재하는 메소드만 수정하고 다른 메소드들은 수정하지 않도록 관심사를 메소드 추출을 이용해 분리 
  2. #### 상속을 통한 관심사 분리
     - 사용 이유 : UserDao에서 DB 생성 방법을 UserDao 코드 수정 없이 변경하지 못하기 때문
     - 해결 방법 : db 생성 방법을 슈퍼 클래스의 코드에서 분리하고 서브 클래스에서 db 생성 방법을 결정하여 UserDao 수정 없이 UserDao 서브 클래스만 변경
  3. #### 클래스로 관심사 분리
     - 사용 이유 : UserDao에서 사용하는 DB 생성 방법을 다른 Dao에서 사용하지 못하기 때문
     - 해결 방법 : DB 생성 방법을 클래스로 분리하여 Dao 속성 값으로 가져, 다른 Dao에서도 db 생성 방법을 분리한 클래스를 사용할 수 있도록 해결
  4. #### 인터페이스를 이용한 관심사 분리
     - 사용 이유 : UserDao가 사용하는 db 생성 방법이 변경될 때, 다른 db 생성 방법의 메소드가 변경될 경우 UserDao에서 db를 사용하는 메소드가 모두 변경되어야 하는 문제가 발생한다.  
     예를 들어 NConnection Maker는 openConection()을 이용해 커넥션을 가져온 반면 DConnection Maker는 getConnection()를 이용해 커넥션을 가져오는 경우, NConnection Maker에서 DConnection Maker를 사용하도록 변경하면 커넥션 메이커를 사용하는 메서드들의 이름을 모두 변경해주어야 한다.
     - 해결 방법 : 인터페이스를 사용하여 커넥션을 가져오는 메소드의 이름을 제한하여 동일한 메소드로 커넥션을 가져오도록 하는데, 이것을 인터페이스를 이용해 해결한다.
  5. #### 클라이언트의 관계 설정 분리
     - 사용 이유 : UserDao가 인터페이스와 인터페이스 구현체 모두를 의존하고 있어, 구현체 변경 시 기존 클라이언트 코드를 변경해야 하는 문제가 발생한다.
     - 해결 방법 : UserDao는 인터페이스에만 의존하고, 외부의 클라이언트에서 UserDao의 생성자를 통해 인터페이스 구현체를 전달하는 방식으로 객체 생성/관계 설정과 객체 사용 관심사를 분리하여 해결한다.
  6. #### 오브젝트 팩토리를 사용하여 사용과 객체 생성/연관관계 설정 관심사 분리
     - 사용 이유 : 클라이언트는 테스트 코드를 실행하고, 객체를 사용, 객체 생성/연관 관계 설정하는 책임을 가지고 있어 너무 많은 책임을 가지고 있는 문제가 발생한다.
     - 해결 방법 : 클라이언트는 테스트 코드를 실행하고, 객체를 사용하는 책임만 가질 수 있도록, 객체 생성 및 관계 설정 책임을 오브젝트 팩토리에 위임하는 방식을 통해 해결한다.
  7. #### ioc 컨테이너(애플리케이션 컨텍스트)를 통해 범용적이고 유연하게 애플리케이션에 ioc를 적용
     - 사용 이유 : 애플리케이션이 커져 오브젝트 팩토리가 많아지고, 클라이언트가 원하는 오브젝트를 얻기 위해 어떤 오브젝트 팩토리를 사용해야 하는지 확인해야 하는 문제가 발생한다.
     - 해결 방법 : 애플리케이션이 커져 설정 정보가 많아져도, 애플리케이션 컨텍스트에서 오브젝트를 getBean()을 통해 일관된 방식으로 찾을 수 있도록 하는 애플리케이션 컨텍스트를 사용하여 해결한다.
<br>
     
- ### di는 무엇인가?
  - 런타임에 외부에서 생성한 의존 오브젝트를 전달하여 의존 오브젝트와 의존 오브젝트를 사용하는 클라이언트의 의존관계를 연결해주는 것
- ### 응집도가 무엇인가?
  - 객체나 모듈이 하나의 관심사 또는 책임에 얼마나 집중했는지를 말하는 것이다
  - 높은 응집도는 객체가 하나의 관심사 또는 책임에 집중하고 있는 것을 말하며, 객체에서 변경이 일어났을 때, 객체의 많은 부분이 바뀌는 것을 의미하기도 한다.
- ### 초난감 DAO에서 최종 리팩토링한 코드에서 생성자로 ConnectionMaker를 넘겨주는데, 이 부분을 비판해 볼 수 있는가?
  - 초난감 DAO에서는 ConnectionMaker가 아니라 Connection 객체를 사용하는 것이기 때문에, ConnectionMaker가 아니라 Connectoin을 넘겨주는 방식이 더 옳다고 생각한다.
  - 그 이유는 초난감 DAO에서 Connection을 넘기게 되면 ConnectionMaker를 동작할 책임을 가질 필요가 없어지고 초난감 DAO는 Connection만 필요로 하기 때문이다.